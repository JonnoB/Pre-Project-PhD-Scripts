---
title: "Untitled"
author: "Jonathan Bourne"
date: "7 January 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

This code explores the effect of what is removed on the amount of overloads/islands/targeted on the system

#Setup Block

```{r}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "zoo", "stringr","foreach", "doMC",  "xtable", "geomnet", "ggnetwork", "rlang", "animation", "ggridges", "poweRlaw", "Rtsne", "caret", "ranger", "xtable", "broom", "modelr", "yardstick", "sf", "rgdal", "ggtern")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


sapply(packages, library, character.only = TRUE)


lapply(packages, library, character.only = TRUE)
library(PowerGridNetworking)

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
#LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Proportional Line Limits" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Tariff <- file.path(basewd,"Tariff and Transport")
#PLwd <- "/media/jonno/Seagate Expansion Drive/Innoculation"
Deletion_Order_Folder <-  file.path("/home/jonno/Dropbox/AWS_Simulation_Files") #Only one of the deletion order folders is needed. Either Nodes or Edges


#Load necessary datasets and great the base powergrid network
source(file.path("/home/jonno/ProportionalLoading", "CreateGBase.R"))

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))



#FOr NetSci
#FiguresFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/NetSci2018 Poster/Figures"
```

#Create the Attack Orders
```{r}


#Ensure there is powerflow
g <- PowerFlow(gbase, "FECK")

g %>%
  simplify(., remove.multiple = T, remove.loops = T) %>% 
    plot(.,vertex.size=.8, edge.arrow.size=.4, vertex.label=NA)

```


Get the round number that an edge was deleted.

```{r}


AllRemovedNodes <- list.files(Deletion_Order_Folder, full.names = TRUE) %>%
  map_df(~read_rds(.x))


OverloadType <- list.files(Deletion_Order_Folder, 
           pattern = "RandomAttack_", 
           full.names = TRUE) %>%
  map_df(~{
    print(.x)
    list.files(.x, full.names = T) %>%
      map_df(~{
        readRDS(.x) %>%
          #filter(type == "Edge") %>%
          group_by(Name, RemovalType, type) %>%
          summarise(counts = n()) %>%
          spread(key = RemovalType, value = counts, fill = 0) 
      })
    
  }) %>%
  group_by(Name, type) %>%
  summarise_all(sum)

  
  OverloadType %>%
    filter(type == "Node") %>%
  ggtern(aes(Islanded,  Targeted, Overloaded)) + 
    geom_point() +
    ggtitle("Ternary plot of the different failure types")
  
LongProb <-    OverloadType %>%
    filter(type == "Edge") %>%
  select(-type) %>%
    gather(key = FailureType, value = value, -Name) %>% 
    mutate(value = value/10000) 
  
  LongProb %>%
    ggplot(aes(x = value, colour = FailureType)) + 
    geom_density() +
    labs(title = "Probability density of edge failure type", x = "Proability of failure")
    

Mapdf <- MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
  left_join(LongProb, by = c("Link"="Name"))
  left_join(LongProb, by = c("Node"="Name"))
  
#using the actual value as well as the rank is interesting, but you need to change the midpoint value
Mapdf %>%
  filter(!is.na(value)) %>%
  group_by(FailureType) %>%
  mutate(rank = ntile(value, 100)) %>%
  ungroup %>%
    ggplot(aes(x = Latitude, y = Longitude)) + 
  geom_line(aes(colour = rank, group = Link)) + 
   facet_grid(PositionType~FailureType) +
   scale_colour_gradient2(low = "blue",mid = "black", high = "red", midpoint = 50)

Mapdf %>%
  filter(!is.na(value)) %>%
  group_by(FailureType) %>%
  mutate(rank = ntile(value, 100)) %>%
  ungroup %>%
    ggplot(aes(x = Latitude, y = Longitude)) + 
    geom_line(aes(group = Link)) +
  geom_point(aes(colour = rank)) + 
   facet_grid(PositionType~FailureType) +
   scale_colour_gradient2(low = "blue",mid = "black", high = "red", midpoint = 50)

```

What is the relationship between centrality and e-centrality and loss mode
```{r}

  ElecCen1 <- ElectricalCentrality(g)
  
   StratAttackVect <-  c(AttackOrderNames(g, degree),
                         AttackOrderNames(g, EntropicDegree, Scale = TRUE),
                         AttackOrderNames(g, EntropicDegree,  value = "PowerFlow", Scale = TRUE),
                         ElecCen1$NodeEC %>% arrange(-NodeEC) %>% .$Bus.Name,
                         AttackOrderNames(g, betweenness)) 
   
   
test   <- tibble(degree = degree(g), 
   EntropicDeg = EntropicDegree(g, Scale = T), 
   EntropicPower = EntropicDegree(g,  value = "PowerFlow", Scale = TRUE),
   ElecCen = ElecCen1$NodeEC$NodeEC,
   Cent = betweenness(g, normalized = T)
   ) %>%
     mutate_all(~{ifelse(is.finite(.), ., 0)}) %>%
  mutate(Name = get.vertex.attribute(g, "name")) %>%
  left_join(OverloadType %>% filter(type =="Node")) %>%
  select(-Name,-type) %>%
  filter(complete.cases(.))
   

#Degree correlates strongly with centrality
#Degree and centrality are both negatively corellated with Islanding and positively corellated with targetting
#there is only a very weak negative corellation between overloading and degree
cor(test)

test2 <- ElecCen1$EdgeEC %>%
  rename(Name = Edgename) %>%
  left_join(OverloadType %>% filter(type == "Edge")) %>%
  left_join(tibble(Name = get.edge.attribute(g, "name"), Centrality = edge_betweenness(g, directed = F))) %>%
filter(complete.cases(.))


test2 %>%
  select(-Name, -type) %>%
  cor



```


```{r}
 LossFractionByRound <- AllRemovedNodes %>%
  group_by(Sim, alpha, type, RoundRemoved, RemovalType) %>%
  summarise(counts = n()) %>%
  group_by(Sim, alpha, type, RemovalType) %>%
  mutate(cumsum = cumsum(counts)) %>%
  group_by(alpha, type, RoundRemoved, RemovalType) %>%
  summarise(mean = mean(counts),
            median = median(counts),
            sd = sd(counts),
            cummean = mean(cumsum),
            cummedian = median(cumsum),
            cumsd = sd(cumsum)) %>%
  left_join(tibble(type = c("Edge", "Node"), 
                    tot = c(ecount(gbase), vcount(gbase)))
            ) %>%
  group_by(alpha, type, RemovalType) %>%
  mutate( test = cumsum(median),
          testfrac = test/tot,
    cummeanfrac = cummean/tot,
            cummedianfrac = cummedian/tot)



#This plot shows that randonly attacking all nodes is LESS effective than targeting a subset of nodes in terms of islanding.
#However there is basically no overloading when targeting the subsets
LossFractionByRound %>%
  filter(RoundRemoved<100) %>% #Keep everything on rought the same scale
  filter(type == "Node", RemovalType != "Targeted") %>%
  ggplot(aes(x = RoundRemoved, y = cummean, group = alpha, colour = alpha)) + geom_line() + 
  facet_wrap(~RemovalType, scales = "free_y")
  


Loss2 <- AllRemovedNodes %>%
  group_by(Sim, alpha, type, RoundRemoved, RemovalType) %>%
  summarise(counts = n()) %>%
  group_by(Sim, alpha, type, RemovalType) %>%
  mutate(cumsum = cumsum(counts)) 


Loss2 %>%
  filter(type == "Node", RemovalType == "Islanded") %>%
  ggplot(aes(x = RoundRemoved, y = cumsum, group = Sim, colour = alpha)) + geom_line() + 
  facet_wrap(.~alpha) +
  coord_cartesian(xlim = c(0,100), ylim = c(0,300))


Loss3 <- Loss2 %>%
  group_by(Sim, type, alpha, RemovalType) %>%
  summarise(cumsum = max(cumsum)) %>%
  spread(key = RemovalType, value = cumsum)

#Strong negative corellation with between Targeted and overload for edge removal, but also for Islanded... What?
Loss3 %>%
  filter(type == "Node", alpha != "AllNodes") %>%
  ggplot(aes(x = Islanded, y = Targeted)) +
  geom_point()+ 
  facet_wrap(.~alpha)

   Loss3 %>%
 # filter(type == "Node", alpha == "Real_Limits") %>%
     group_by(alpha, type) %>%
     summarise(corTargOver = cor(Targeted, Overloaded, use =  "pairwise.complete.obs"),
               corTargIsl = cor(Targeted, Islanded, use =  "pairwise.complete.obs"),
               corOverIsl = cor(Overloaded, Islanded, use =  "pairwise.complete.obs")) %>%
     arrange(type)
   
   

   #There Only the full random attack has overloads   
 AllRemovedNodes %>%
     filter(RoundRemoved<100) %>% #Keep everything on rought the same scale
  group_by(type, alpha, Sim, RemovalType) %>%
  summarise(counts = n()) %>%
 #bind_rows(., NumberofRounds) %>%
     filter(type == "Node") %>%
   ggplot(aes(x = alpha, y = counts)) + geom_boxplot() + 
   facet_wrap(type~RemovalType, scales = "free_y") +
    theme(legend.position = "none", 
        axis.text.x = element_text(angle = 45, hjust = 1)) 


```

