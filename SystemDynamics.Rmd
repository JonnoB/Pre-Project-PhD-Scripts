---
title: "Untitled"
author: "Jonathan Bourne"
date: "22 March 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---



```{r}
library(tidyverse)

list.files("/home/jonno/Useful_PhD__R_Functions", pattern = "Tension", full.names = T) %>%
  walk(~source(.x))


theta_force <- seq(0,pi/2, 0.05 )


k = 300
dist <- sqrt(2)
force = 60
test <- tibble(Tension = force/sin(theta_force), adjacent = force/tan(theta_force), 
       opposite = force,
       elongation = Tension/k,
       theta_force = theta_force,
       theta_dist = acos(dist/(dist+elongation)),
       theta_diff = theta_force-theta_dist,
       height = sqrt((dist+ elongation)^2- dist^2))

test %>%
  arrange(abs(theta_diff)) %>% slice(1)

ggplot(test, aes(x = theta_force, y = theta_diff))+ geom_point()

```




```{r}
k1<- 2.5
k2 <- 3
F1<- 15
F2<- -25
F3 <- 10

D1 <- 1
D2 <-1.5
Dvect <- seq(0.01, 20, 0.001)

test <-tibble(z = Dvect, DX1 = sqrt(z^2 + D1^2)-D1, DX2 = sqrt(z^2 + D2^2)-D2, Ft1 = k1*DX1, Ft2 = k2*DX2, 
       F1u = Ft1*z/(DX1+D1), F2u = Ft2*z/(DX2+D2), difference = F1u+F2u+F3, min = abs(difference))


ggplot(test, aes(x = z, y = min))+ geom_point()


Fvect <- c(F1,-F3,F2)

test %>% arrange(min) %>% slice(1) %>% pull(z) %>% c(0,.,0) %>%
  tibble(ID  = 1:3, Fvect, height = -. ) %>%
  ggplot(., aes(x = ID, y = height)) + geom_point(size = 5) +
  geom_line()


EdgeNode <- c(1,-1,0,0,0,0,
              0,1,-1,0,0,0,
              0,0,0,1,-1,0,
              0,0,0,1,-1,0,
              0,0,0,0,1,-1,
              0,0,0,1,0,-1,
              0,1,0,0,-1,0
              ) %>% matrix(nrow = 7, byrow = T)

Link <- tibble(EdgeName = 1:7, 
               distance = c(sqrt(2), sqrt(2), sqrt(2), sqrt(2), 1,1, sqrt(2)),
               k = c(5,2,2.5,4,4,3,1))

  C <- matrix(data = 0, nrow = nrow(Link), ncol = nrow(Link))
  diag(C) <- Link$distance

#Injection vector of power put in and removed
InjectionVect <- c(10,20,0,-20,10,-20)
sum(InjectionVect)

InjectMat <- diag(InjectionVect)


Adj <- (t(EdgeNode) %*% diag(1, nrow = nrow(EdgeNode)) %*% EdgeNode) / (t(EdgeNode) %*% diag(1, nrow = nrow(EdgeNode)) %*% EdgeNode) 
diag(Adj) <-0
Adj[!is.finite(Adj)] <-0
Adj

graph_from_adjacency_matrix(Adj, mode = "undirected") %>% plot

Zvect <- c(1,2,0,-1,-2,-2)

HeightDiff <- t(Adj * Zvect) - (Adj * Zvect) 
D <- t(EdgeNode) %*% C %*% EdgeNode %>% abs
diag(D) <-0

# Tension <- function(dZ,k, D){
#   
#   k*(sqrt(dZ^2+ D^2)-D)*dZ/(sqrt(dZ^2+ D^2))
#   
# }

kvect <- Link$k
dvect <- Link$distance

SmallEdgeNode <- matrix(c(1,-1,0,
                   0,1,-1), nrow = 2, byrow = T)
Smallzvect <- c(2,-1,1)
Smallkvect <- c(3,4)
Smalldvect <- c(1,1)

Create_Tension_matrix(SmallEdgeNode, Smallzvect, Smallkvect, Smalldvect)

Create_Tension_matrix(SmallEdgeNode, Smallzvect, Smallkvect, Smalldvect) %>%
  rowSums()


Calc_Damping_matrix(SmallEdgeNode, 0, Smallkvect, 
                    c(5,5,5))

```



```{r}

velocity <- function(u, a, t0, t1){
  #calculates the velocity of an object given and initial velocity an acceleration and time difference
  #u initial velocity
  #a acceleration
  #t0 initial time
  #t1 next time period
  
  return(u + a*(t1-t0))
}


distance <- function(z, v, a, t0, t1 ){
  #Calculates the total distance a node will be from the origin for a given time step
  #z, distance at current time
  #v velcoity at current time
  #a acceleration
  #t0 current time
  #t1 time at and of time step
  
  return(v*(t1-t0) + 0.5*a*(t1-t0) + z)
  
}





#MASS CAN'T BE ZERO!

NodeStatus2 <- tibble(node = 1:6, mass = 5, force = c(10,20,0,-20,10,-20), z = 0, 
       NetTension = 0, velocity = 0, 
       friction = 0,
       NetForce = NetTension + force - friction,
       acceleration = NetForce/mass,
       t = 0)




SmallNodeStatus <- tibble(node = 1:3, mass = 5, force = c(10,0,-10), z = 0, 
       NetTension = 0, velocity = 0, 
       friction = 0,
       NetForce = force + NetTension +friction,
       acceleration = NetForce/mass,
       t = 0)

Smalltest <-FindStabilSystem(SmallNodeStatus, SmallEdgeNode, Smallkvect, Smalldvect, tstep=0.01, maxIter = 10000, frctmultiplier = 0.01) %>%
  bind_rows()

Create_Tension_matrix(SmallEdgeNode, smallzvect , Smallkvect, Smalldvect)

Calc_Damping_matrix(SmallEdgeNode, Smalltest %>% filter(t == 1) %>% pull(velocity), Smallkvect, 
                    Smalltest %>% filter(t == 1) %>% pull(mass))

Smalltest %>%
  group_by(t) %>%
  summarise(z = mean(abs(z)),
            NetForce = mean(abs(NetForce)),
            velocity = mean(abs(velocity)),
            acceleration = mean(abs(acceleration))) %>%
  ggplot(aes(x = t, y =z )) + geom_line()


Smalltest  %>%
  mutate(node = factor(node)) %>%
  ggplot(aes(x = t, y =z , colour = node)) + geom_line()

```


#Test real graph

```{r}
#Create Edge matrix from graph

A <- as_data_frame(List_of_BiConComps[[147]]) %>% 
  select(Link, from, to) %>% 
  gather(key = type, Node, -Link) %>%
  arrange(Node) %>%
  mutate(value = ifelse(type =="from", 1, -1)) %>%
  ungroup %>%
  select(-type) %>%
  spread(key = Node, value, fill = 0) %>%
  arrange(Link)

rowdat <- A$Link

A <- A %>% select(-Link) %>%
  as.matrix()

rownames(rowdat)

rm(rowdat)


NodeStatus <- as_data_frame(List_of_BiConComps[[147]], what = "vertices") %>%
  select(node = name, force = BalencedPower ) %>%
  mutate(
    z = 0,
    mass = 2000,
    NetTension = 0, velocity = 0, 
       friction = 0,
       NetForce = force + NetTension - friction,
       acceleration = NetForce/mass,
       t = 0) %>%
  filter(!(node %in% deletenames))

NodeStatus$force %>% sum

testratio <- NodeStatus %>%
  mutate(ratio = abs(force/mass))


Link <- as_data_frame(g) %>%
  mutate(EdgeName = Link, distance = 1/Y, alpha = Link.Limit/abs(PowerFlow),  k= 1000*(1-1/alpha)) %>% #arbitary k!
  select(EdgeName, distance, k) 

test <-FindStabilSystem(NodeStatus, A, Link$k, Link$distance, tstep= 0.5, maxIter = 2000, frctmultiplier = 1) %>%
  bind_rows()

test <-FindStabilSystem2(NodeStatus, A, Link$k, Link$distance, tstep= 0.5, maxIter = 2000, frctmultiplier = 1) 



 test$results %>%
  ggplot(aes(x = t, y =z)) + geom_line()

test2 <- test$NodeList
 
summtest <- test %>%
  group_by(t) %>%
  summarise(z = mean(abs(z)),
            NetForce = mean(abs(NetForce)),
            velocity = mean(abs(velocity)),
            acceleration = mean(abs(acceleration))) 

summtest %>%
  ggplot(aes(x = t, y = z)) + geom_line()


testnode <- test %>%
  filter(node =="DUGR")

testnode %>%
  ggplot(aes(x = t, y = z )) + geom_line()


finalround <- test %>%
  filter(t == max(t))

#k1e4 <- test
#k10 <- test
#k100Iter2k <- test

test <- k1e4

```



```{r}

smallBi <- biconnected_components(graph_from_adjacency_matrix(Adj, mode = "undirected"))

smallBi$components[[1]] %>% length
  
bigraph <- biconnected_components(g)

bigraph %>% names

NodesPerComponent <- bigraph$components %>%
  map_dbl(~length(.x)) %>%
  tibble(components = 1:length(.), counts = .)


get_bicomp_power <- function(g, component_number){

  DeleteNodes <- get.vertex.attribute(g, "name")[!get.vertex.attribute(g, "name") %in% V(g)$name[bigraph$components[[component_number]]]]

  delete.vertices(g, DeleteNodes) %>% get.vertex.attribute(., "BalencedPower") %>% sum
}


BicompPower <- 1:length(bigraph$components) %>%
  map_df(~{
    
    tibble(BiComp = .x, Power = get_bicomp_power(g, .x))
    
  })

#create a sub graph that includes all the bicomponent of a node except the one that includes the active bi-comp



List_of_BiConComps <- Create_balanced_blocks(g)

#use the largest block to set the simulation parameters k and m.
#k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
OriginBlock <- Find_network_balance(List_of_BiConComps[[147]], tstep = 0.1, tol = 1e-10, maxIter = 4000, kbase = 50, kdiff = 300, mass = 500)

BlockNumbers <-(1:length(List_of_BiConComps))[-147]

StabilModels <- BlockNumbers %>% 
  map(~{
    
    Out <- Find_network_balance(List_of_BiConComps[[.x]], tstep = 0.1, tol = 1e-10, maxIter = 4000, kbase = 200, kdiff = 1000, mass = 500, verbose = FALSE)
    
    print(paste("Block" ,.x, "of", max(BlockNumbers) ,"termination", nrow(Out$results) ))
    #print(Out$results)
    return(Out)
    
    })

test2 <- StabilModels[[127]]$result

StabilModels[[127]]$NodeList

ggplot(OriginBlock$results, aes(x = t , y = z)) + geom_line()

FinalRound <- StabilModels %>% 
  map_df(~{
    
    .x$result %>%
  filter(t == max(t))

  })


FinalRound %>%
  filter(acceleration <2e-6) %>%
  ggplot(aes(x = velocity, y = acceleration)) + 
  geom_point()

```


```{r}

Block_tree <- biconnected_components(g)

ArticulationVect <- get.vertex.attribute(g, "name", Block_tree$articulation_points)

relative_blocks1 <- 1:length(StabilModels) %>% 
  map_df(~{
    
    StabilModels[[.x]]$NodeList %>%
      mutate(Reference_ID = .x)

  }) %>%
  bind_rows(OriginBlock$NodeList %>% 
              mutate(Reference_ID = 0)) %>%
  mutate(Articulation_node = (node %in% ArticulationVect ))


#The height of each node relative to the origin and normalised
final_z <-fix_z_to_origin(relative_blocks1, ArticulationVect) %>%
  group_by(node) %>%
  summarise_all(first) 
%>%
  mutate(z = z/sd(z))
# 
# 
# final_z %>%
#   ggplot(aes(x = z)) + geom_density() 
# 
# final_z %>%
#   ggplot(aes(x = z, y = force)) + geom_point() +
#   labs(title = "Distance from Z relative to force exerted on system")

mean(final_z$z)
median(final_z$z)

#Is the strain power law distributed?
line_strain <-as_data_frame(g) %>%
  left_join(., final_z %>% select(node, z), by = c("from"= "node")) %>%
  left_join(., final_z %>% select(node, z), by = c("to"= "node")) %>%
  mutate(D = 1/Y,
         dz = abs(z.x-z.y),
         mean_z = (z.x+z.y)/2,
         H = sqrt(dz^2 +D^2),
         strain = (H-D)/D,
         alpha = Link.Limit/abs(PowerFlow),
         line_load = abs(PowerFlow)/Link.Limit,
         percentile_strain = percent_rank(strain)) %>%
  select(Link, alpha, line_load, dz, H, strain, percentile_strain, mean_z)

cor(line_strain$dz, line_strain$strain)
cor(line_strain$line_load, line_strain$strain)


z_network_map <-MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
  left_join(line_strain, by = c("Link"))%>%
   left_join(., final_z %>% select(node, z), by = c("Node"= "node")) 

z_network_map %>%
  #filter(!is.na(Perc)) %>%
    ggplot(aes(x = Latitude, y = Longitude)) + 
  geom_line(aes(group = Link, colour =percent_rank(line_load)), size = 0.8) + 
   facet_grid(~PositionType) + 
 # geom_point( aes(x = Latitude, y = Longitude, colour = percent_rank(z))) + 
  scale_color_viridis_c()+
  ggtitle("Strain map")

 
z_network_map %>%
  ggplot(aes(x = Latitude, y = mean_z, colour = percentile_strain)) + geom_point()+ scale_color_viridis_c()

```


```{r}
library(sf)
library(gstat)

node_z <-z_network_map %>%
  filter(PositionType=="Geo Space") %>%
  select(Node, Longitude, Latitude, z) %>%
  distinct(.keep_all = T)

shapefile <- file.path("/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ShapeFiles UK",
                       "Countries_December_2017_Ultra_Generalised_Clipped_Boundaries_in_UK_WGS84.shp")


GB <- st_read(shapefile) %>%
  filter(ctry17cd !="N92000002") %>%
  st_union()

ggplot(GB) +
  geom_sf() +
 # scale_fill_viridis("Area") +
  ggtitle("Node locations in the UK") +
  theme_bw() +
  geom_line(data = z_network_map %>%
              filter(PositionType=="Geo Space"),  aes(y = Longitude, x = Latitude, group = Link)) +
   geom_point(data =node_z, aes(y = Longitude, x = Latitude, colour = z), alpha  = 0.7)+
  coord_sf(ylim = c(50,58.9)) +
  scale_color_viridis_c()

spdf <- as(GB, "Spatial")

grd <- makegrid(spdf, n = 15000)
colnames(grd) <- c('x','y')

grd_pts <- SpatialPoints(coords = grd, 
                         proj4string=CRS(proj4string(spdf)))

# find all points in `grd_pts` that fall within `spdf`
grd_pts_in <- grd_pts[spdf, ]

# transform grd_pts_in back into a data frame
gdf <- as.data.frame(coordinates(grd_pts_in)) %>%
  filter(y<59)


#create spatial points of height data
DT_sf  <-  st_as_sf(node_z, coords = c("Latitude","Longitude"),
                        crs = "+proj=longlat +datum=WGS84", agr = "constant")%>% 
  as_Spatial %>%
  remove.duplicates() #remove duplicate points aka points super close

#create spatial points of data that will have z interpolated
grd_sf  <-  gdf %>% 
    rename(Longitude = y, Latitude = x) %>%
  st_as_sf(., coords = c("Latitude","Longitude"),
                        crs = "+proj=longlat +datum=WGS84", agr = "constant") %>%
  as_Spatial



#create variogram of data
dt.vgm <- variogram(z~1, DT_sp)


dt.fit <-fit.variogram(dt.vgm, model = vgm(1,"Lin",900,1)) # fit model

# vgm() list of models

plot(dt.vgm, dt.fit)


lzn.kriged <- krige((z) ~ 1, remove.duplicates(DT_sp), grd_sp, model=dt.fit) #remove duplicate locations

lzn.kriged %>% as.tibble %>% rename(lon=coords.x1, lat=coords.x2) %>% 
  ggplot(aes(x=lon, y=lat)) + geom_tile(aes(fill=var1.pred)) +coord_equal() +
  scale_fill_viridis_c() +
  labs(title = "height of network across the  UK")



kriged_df <- lzn.kriged %>% as.tibble %>%
  rename(Z = var1.pred) %>%
  select(-var1.var)

kriged_df2 <- kriged_df %>%
  spread(key = coords.x1, value = coords.x2, fill = 0) %>% as.matrix()

kriged_df2

```
