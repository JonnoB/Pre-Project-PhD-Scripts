---
title: "Untitled"
author: "Jonathan Bourne"
date: "22 March 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---



```{r}

EdgeNode <- c(1,-1,0,0,0,0,
              0,1,-1,0,0,0,
              0,0,0,1,-1,0,
              0,0,0,1,-1,0,
              0,0,0,0,1,-1,
              0,0,0,1,0,-1,
              0,1,0,0,-1,0
              ) %>% matrix(nrow = 7, byrow = T)

Link <- tibble(EdgeName = 1:7, 
               distance = c(sqrt(2), sqrt(2), sqrt(2), sqrt(2), 1,1, sqrt(2)),
               k = c(5,2,2.5,4,4,3,1))

  C <- matrix(data = 0, nrow = nrow(Link), ncol = nrow(Link))
  diag(C) <- Link$distance

#Injection vector of power put in and removed
InjectionVect <- c(10,20,0,-20,10,-20)
sum(InjectionVect)

InjectMat <- diag(InjectionVect)


Adj <- (t(EdgeNode) %*% diag(1, nrow = nrow(EdgeNode)) %*% EdgeNode) / (t(EdgeNode) %*% diag(1, nrow = nrow(EdgeNode)) %*% EdgeNode) 
diag(Adj) <-0
Adj[!is.finite(Adj)] <-0
Adj

graph_from_adjacency_matrix(Adj, mode = "undirected") %>% plot

Zvect <- c(1,2,0,-1,-2,-2)

HeightDiff <- t(Adj * Zvect) - (Adj * Zvect) 
D <- t(EdgeNode) %*% C %*% EdgeNode %>% abs
diag(D) <-0

kvect <- Link$k
dvect <- Link$distance

SmallEdgeNode <- matrix(c(1,-1,0,
                   0,1,-1), nrow = 2, byrow = T)
Smallzvect <- c(2,-1,1)
Smallkvect <- c(3,4)
Smalldvect <- c(1,1)

Create_Tension_matrix(SmallEdgeNode, Smallzvect, Smallkvect, Smalldvect)

Create_Tension_matrix(SmallEdgeNode, Smallzvect, Smallkvect, Smalldvect) %>%
  rowSums()


Calc_Damping_matrix(SmallEdgeNode, 0, Smallkvect, 
                    c(5,5,5))

```



```{r}

#MASS CAN'T BE ZERO!

NodeStatus2 <- tibble(node = 1:6, mass = 5, force = c(10,20,0,-20,10,-20), z = 0, 
       NetTension = 0, velocity = 0, 
       friction = 0,
       NetForce = NetTension + force - friction,
       acceleration = NetForce/mass,
       t = 0)




SmallNodeStatus <- tibble(node = 1:3, mass = 5, force = c(10,0,-10), z = 0, 
       NetTension = 0, velocity = 0, 
       friction = 0,
       NetForce = force + NetTension +friction,
       acceleration = NetForce/mass,
       t = 0)

Smalltest <-FindStabilSystem(SmallNodeStatus, SmallEdgeNode, Smallkvect, Smalldvect, tstep=0.01, maxIter = 10000, frctmultiplier = 0.01) %>%
  bind_rows()

Create_Tension_matrix(SmallEdgeNode, smallzvect , Smallkvect, Smalldvect)

Calc_Damping_matrix(SmallEdgeNode, Smalltest %>% filter(t == 1) %>% pull(velocity), Smallkvect, 
                    Smalltest %>% filter(t == 1) %>% pull(mass))

Smalltest %>%
  group_by(t) %>%
  summarise(z = mean(abs(z)),
            NetForce = mean(abs(NetForce)),
            velocity = mean(abs(velocity)),
            acceleration = mean(abs(acceleration))) %>%
  ggplot(aes(x = t, y =z )) + geom_line()


Smalltest  %>%
  mutate(node = factor(node)) %>%
  ggplot(aes(x = t, y =z , colour = node)) + geom_line()

```


#Test real graph

```{r}
#Create Edge matrix from graph

A <- as_data_frame(List_of_BiConComps[[147]]) %>% 
  select(Link, from, to) %>% 
  gather(key = type, Node, -Link) %>%
  arrange(Node) %>%
  mutate(value = ifelse(type =="from", 1, -1)) %>%
  ungroup %>%
  select(-type) %>%
  spread(key = Node, value, fill = 0) %>%
  arrange(Link)

rowdat <- A$Link

A <- A %>% select(-Link) %>%
  as.matrix()

rownames(rowdat)

rm(rowdat)


NodeStatus <- as_data_frame(List_of_BiConComps[[147]], what = "vertices") %>%
  select(node = name, force = BalencedPower ) %>%
  mutate(
    z = 0,
    mass = 2000,
    NetTension = 0, velocity = 0, 
       friction = 0,
       NetForce = force + NetTension - friction,
       acceleration = NetForce/mass,
       t = 0) %>%
  filter(!(node %in% deletenames))

NodeStatus$force %>% sum

testratio <- NodeStatus %>%
  mutate(ratio = abs(force/mass))


Link <- as_data_frame(g) %>%
  mutate(EdgeName = Link, distance = 1/Y, alpha = Link.Limit/abs(PowerFlow),  k= 1000*(1-1/alpha)) %>% #arbitary k!
  select(EdgeName, distance, k) 

test <-FindStabilSystem(NodeStatus, A, Link$k, Link$distance, tstep= 0.5, maxIter = 2000, frctmultiplier = 1) %>%
  bind_rows()

test <-FindStabilSystem2(NodeStatus, A, Link$k, Link$distance, tstep= 0.5, maxIter = 2000, frctmultiplier = 1) 



 test$results %>%
  ggplot(aes(x = t, y =z)) + geom_line()

test2 <- test$NodeList
 
summtest <- test %>%
  group_by(t) %>%
  summarise(z = mean(abs(z)),
            NetForce = mean(abs(NetForce)),
            velocity = mean(abs(velocity)),
            acceleration = mean(abs(acceleration))) 

summtest %>%
  ggplot(aes(x = t, y = z)) + geom_line()


testnode <- test %>%
  filter(node =="DUGR")

testnode %>%
  ggplot(aes(x = t, y = z )) + geom_line()


finalround <- test %>%
  filter(t == max(t))

#k1e4 <- test
#k10 <- test
#k100Iter2k <- test

test <- k1e4

```



```{r}

#create a sub graph that includes all the bicomponent of a node except the one that includes the active bi-comp

List_of_BiConComps <- Create_balanced_blocks(g)

#use the largest block to set the simulation parameters k and m.
#k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
OriginBlock <- Find_network_balance(List_of_BiConComps[[147]], tstep = 0.1, tol = 1e-10, maxIter = 8000, kbase = 50, kdiff = 300, mass = 500)

BlockNumbers <-(1:length(List_of_BiConComps))[-147]

StabilModels <- BlockNumbers %>% 
  map(~{
    
    Out <- Find_network_balance(List_of_BiConComps[[.x]], tstep = 0.1, tol = 1e-10, maxIter = 4000, kbase = 200, kdiff = 1000, mass = 500, verbose = FALSE)
    
    print(paste("Block" ,.x, "of", max(BlockNumbers) ,"termination", nrow(Out$results) ))
    #print(Out$results)
    return(Out)
    
    })

test2 <- StabilModels[[127]]$result

StabilModels[[127]]$NodeList

ggplot(OriginBlock$results, aes(x = t , y = z)) + geom_line()

FinalRound <- StabilModels %>% 
  map_df(~{
    
    .x$result %>%
  filter(t == max(t))

  })

FinalRound %>%
  filter(acceleration <2e-6) %>%
  ggplot(aes(x = velocity, y = acceleration)) + 
  geom_point()

```


```{r}

Block_tree <- biconnected_components(g)

ArticulationVect <- get.vertex.attribute(g, "name", Block_tree$articulation_points)

relative_blocks1 <- 1:length(StabilModels) %>% 
  map_df(~{
    
    StabilModels[[.x]]$NodeList %>%
      mutate(Reference_ID = .x)

  }) %>%
  bind_rows(OriginBlock$NodeList %>% 
              mutate(Reference_ID = 0)) %>%
  mutate(Articulation_node = (node %in% ArticulationVect ))


#The height of each node relative to the origin and normalised
final_z <-fix_z_to_origin(relative_blocks1, ArticulationVect) %>%
  group_by(node) %>%
  summarise_all(first) 

# 
# 
# final_z %>%
#   ggplot(aes(x = z)) + geom_density() 
# 
# final_z %>%
#   ggplot(aes(x = z, y = force)) + geom_point() +
#   labs(title = "Distance from Z relative to force exerted on system")

mean(final_z$z)
median(final_z$z)

#Is the strain power law distributed?
line_strain <-as_data_frame(g) %>% as_tibble %>%
  left_join(., final_z %>% select(node, z), by = c("from"= "node")) %>%
  left_join(., final_z %>% select(node, z), by = c("to"= "node")) %>%
  mutate(D = 1/Y,
         dz = abs(z.x-z.y),
         mean_z = (z.x+z.y)/2,
         H = sqrt(dz^2 +D^2),
         strain = (H-D)/D,
         alpha = Link.Limit/abs(PowerFlow),
         line_load = abs(PowerFlow)/Link.Limit,
         percentile_strain = percent_rank(strain)) %>%
  select(Link, alpha, line_load, dz, H, strain, percentile_strain, mean_z)

cor(line_strain$dz, line_strain$strain)
cor(line_strain$line_load, line_strain$strain)


z_network_map <-MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
  left_join(line_strain, by = c("Link"))%>%
   left_join(., final_z %>% select(node, z), by = c("Node"= "node")) 

z_network_map %>%
  #filter(!is.na(Perc)) %>%
    ggplot(aes(x = Latitude, y = Longitude)) + 
  geom_line(aes(group = Link, colour = percentile_strain), size = 0.8) + 
   facet_grid(~PositionType) + 
 # geom_point( aes(x = Latitude, y = Longitude, colour = percent_rank(z))) + 
  scale_color_viridis_c()+
  ggtitle("Strain map")

```

#distance clusters

```{r}

node_z <-z_network_map %>% as_tibble %>%
  filter(PositionType=="Geo Space") %>%
  select(Node, Longitude, Latitude, z) %>%
  distinct(.keep_all = T) 

z_graph <- as_data_frame(g) %>% as_tibble %>%
  left_join(., final_z %>% select(node, z), by = c("from"= "node")) %>%
  left_join(., final_z %>% select(node, z), by = c("to"= "node")) %>%
  mutate(D = 1/Y,
         dz = abs(z.x-z.y),
         mean_z = (z.x+z.y)/2,
         H = sqrt(dz^2 +D^2),
         strain = (H-D)/D,
         alpha = Link.Limit/abs(PowerFlow),
         line_load = abs(PowerFlow)/Link.Limit,
         percentile_strain = percent_rank(strain)) %>%
graph_from_data_frame(., vertices = node_z %>% select(Node, z), directed = FALSE ) 

z_mst <- mst(z_graph, weights = get.edge.attribute(z_graph, "dz"))

FailureNodeCommunity_z  <- z_graph %>% 
  cluster_walktrap(.) %>% 
  MakeNodeCommunity()

IsSameCommunity2(FailureNodeCommunity, FailureNodeCommunity_z) %>% pull(Jaccard) %>% mean

distancedf <- distances(g, weights = get.edge.attribute(g, "dz")) %>% as_tibble %>% mutate(from = names(.)) %>%
    gather(key = "to", value = "distance",-from)

#graph clustered based on height distance
distgraph <- distancedf %>% spread(to, distance) %>% select(-from) %>% as.matrix
rownames(distgraph) <- colnames(distgraph)
dist_hclust <- distgraph %>% as.dist %>% hclust(.) 

dist_hclust <- hclust_graph(z_mst)

#True co-failure group
hclust_nodes1 <- hclust_graph(g_cofailure, weight = "weight") %>%
  list(names = names(cutree(., 10)),  membership = cutree(., 10)) %>%
  MakeNodeCommunity(large = 1, medium = 0)

hclust_nodes2 <- hclust_graph(g) %>%
  list(names = names(cutree(., 10)),  membership = cutree(., 12)) %>%
  MakeNodeCommunity(large = 1, medium = 0)

#stress group
hclust_nodes3 <- hclust_graph(z_graph, weight = "H") %>%
  list(names = names(cutree(., 10)),  membership = cutree(., 10)) %>%
  MakeNodeCommunity(large = 1, medium = 0)

#topological
hclust_nodes4 <-  g %>% set.edge.attribute(., "weight", value = rep(1, ecount(.))) %>% #set edge weights to 1
hclust_graph(., weight = "weight")  %>%
  list(names = names(cutree(., 10)),  membership = cutree(., 10)) %>%
  MakeNodeCommunity(large = 1, medium = 0)

MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
  left_join(hclust_nodes1) %>%
#  left_join(VertexMetaData2 %>% rename(Node = Name)) %>%
    ggplot(aes(x = Latitude, y = Longitude)) + 
  geom_line(aes(group = Link), size = 0.8) + 
  geom_point(aes(colour =Community), size = 2) +
   facet_grid(~PositionType) +
    scale_color_brewer(palette = "Paired")+
  labs(title = "Failure groups hierarchically clustered 10 groups")


#There is a strong corellation betweeen Longitude and z and no corellation between latitude and z
node_z %>%
  gather(key = coord, value = value, -z,-Node) %>%
  left_join(final_z %>% select(node, NetTension), by = c("Node"= "node")) %>%
  left_join(hclust_nodes1) %>%
  mutate(Force = percent_rank(abs(NetTension))) %>%
  ggplot(aes(x = value, y = z, colour = Force)) + geom_point() + 
  scale_color_viridis_c() +
  #scale_color_brewer(palette = "Paired")+
  facet_grid(~coord, scales = "free_x") +
  labs(title = "The height of each node and the percent rank Force acting on each node \n relative to the Latitude and Longitude")


node_z %>%
  gather(key = coord, value = value, -z,-Node) %>%
  left_join(final_z %>% select(node, NetTension), by = c("Node"= "node")) %>%
  left_join(hclust_nodes1) %>%
  ggplot(aes(x = value, y = z, colour = Community)) + geom_point() + 
  scale_color_brewer(palette = "Paired")+
  facet_grid(~coord, scales = "free_x") +
  labs(title = "Node cluster membership")

CommSim <- IsSameCommunity2(hclust_nodes1, hclust_nodes3) %>%
  left_join(hclust_nodes2, by = c("Node"= "Node")) %>%
  group_by(membership) %>%
  summarise(Jaccard = mean(Jaccard),
            size = first(size),
            rank = first(rank) %>% as.integer,
            Community = first(Community))



test <-Tree_Similarity(hclust_graph(z_graph, weight = "dz") , 
                       hclust_graph(g_cofailure, weight = "weight"),1,50) %>%
  mutate(type = "depth") %>%
  bind_rows(Tree_Similarity( hclust_graph(g), 
                       hclust_graph(g_cofailure, weight = "weight"),1,50) %>%
  mutate(type = "Line Limit")) %>%
  # bind_rows(Tree_Similarity( hclust_graph(z_mst, weight = "dz"), 
  #                      hclust_graph(g_cofailure, weight = "weight"),1, 50) %>%
  # mutate(type = "mst depth")) %>%
    bind_rows(Tree_Similarity(g %>% set.edge.attribute(., "weight", value = rep(1, ecount(.))) %>% #set edge weights to 1
hclust_graph(., weight = "weight") , 
                       hclust_graph(g_cofailure, weight = "weight"),1, 50) %>%
  mutate(type = "topological")) %>%
  bind_rows(Tree_Similarity( hclust_graph(z_graph, weight = "H"), 
                       hclust_graph(g_cofailure, weight = "weight"),1, 50) %>%
  mutate(type = "H dist")) 
  


test %>%
  filter(trees>3) %>%
  ggplot(aes(x = trees, y = mean, colour = type )) + geom_line()

Tree_Similarity(hclust_graph(z_graph, weight = "dz") , 
                       hclust_graph(g_cofailure, weight = "weight"),10,10, node_jaccard = T) %>%
  ggplot(aes(x = Jaccard)) + geom_density()

```

```{r}

test2 <- OverloadType %>%
  filter(type == "Edge") %>% 
  left_join(as_data_frame(z_graph)%>%as.tibble, by = c("Name"="name"))%>%  ungroup 
   
select(test2, Islanded, Overloaded, Targeted, mean_z, H, line_load, strain, percentile_strain, dz) %>% cor

g_cofailure <- DistDF %>%
  select(Node1, Node2, weight = counts) %>%
  filter(weight >=1000) %>% #only edges with at least 1000 occurrances aka 10%, I'm not sure on the rights and wrongs of a cut off. This is definately a case for the metric backbone. Doing this or not makes a substantial difference
  graph_from_data_frame(directed = FALSE)


```



```{r}

node_heights <- tibble(node = get.vertex.attribute(z_mst, "name"), z = get.vertex.attribute(z_mst, "z")) %>%
  mutate(rank = rank(z))

remove_nodes <- node_heights %>%
  filter(rank>2) %>% pull(node)

g_temp <- delete.vertices(z_mst, remove_nodes) 
plot(g_temp)

g_non_single <- delete.vertices(g_temp, get.vertex.attribute(g_temp,"name" )[degree(g_temp)==0])

who_is_with_who <- tibble(name = names(components(g_non_single)$membership), component = components(g_non_single)$membership)


#how to make a hclust object
a <- list()  # initialize empty object
# define merging pattern: 
#    negative numbers are leaves, 
#    positive are merged clusters (defined by row number in $merge)
a$merge <- matrix(c(-1, -2,
                    -3, -4,
                     1,  2), nc=2, byrow=TRUE ) 
a$height <- c(1, 1.5, 3)    # define merge heights
a$order <- 1:4              # order of leaves(trivial if hand-entered)
a$labels <- LETTERS[1:4]    # labels of leaves
class(a) <- "hclust"        # make it an hclust object
plot(a)                     # look at the result   

#convert to a dendrogram object if needed
ad <- as.dendrogram(a)

```

#Kriging
```{r}
library(sf)
library(gstat)


shapefile <- file.path("/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ShapeFiles UK",
                       "Countries_December_2017_Ultra_Generalised_Clipped_Boundaries_in_UK_WGS84.shp")


GB <- st_read(shapefile) %>%
  filter(ctry17cd !="N92000002") %>%
  st_union()

ggplot(GB) +
  geom_sf() +
 # scale_fill_viridis("Area") +
  ggtitle("Node locations in the UK") +
  theme_bw() +
  geom_line(data = z_network_map %>%
              filter(PositionType=="Geo Space"),  aes(y = Longitude, x = Latitude, group = Link)) +
   geom_point(data =node_z, aes(y = Longitude, x = Latitude, colour = z), alpha  = 0.7)+
  coord_sf(ylim = c(50,58.9)) +
  scale_color_viridis_c()

spdf <- as(GB, "Spatial") %>% st_as_sf %>%
  st_crop(c(xmin = -7.5, ymin = 50, xmax = 1.5, ymax = 59)) %>%
  as_Spatial()

grd <- makegrid(spdf, n = 200)
colnames(grd) <- c('x','y')

grd_pts <- SpatialPoints(coords = grd, 
                         proj4string=CRS(proj4string(spdf)))

# find all points in `grd_pts` that fall within `spdf`
grd_pts_in <- grd_pts[spdf, ]

# transform grd_pts_in back into a data frame
gdf <- as.data.frame(coordinates(grd_pts_in))


#create spatial points of height data
DT_sf  <-  st_as_sf(node_z, coords = c("Latitude","Longitude"),
                        crs = "+proj=longlat +datum=WGS84", agr = "constant")%>% 
  as_Spatial %>%
  remove.duplicates() #remove duplicate points aka points super close

#create spatial points of data that will have z interpolated
grd_sf  <-  gdf %>% #expand.grid(x =unique(gdf$x), y = unique(gdf$y)) %>% as.tibble %>% #if expand grid isn't used problems
    rename(Longitude = y, Latitude = x) %>%
  st_as_sf(., coords = c("Latitude","Longitude"),
                        crs = "+proj=longlat +datum=WGS84", agr = "constant") %>%
  as_Spatial


#create variogram of data
dt.vgm <- variogram(z~1, DT_sf)


dt.fit <-fit.variogram(dt.vgm, model = vgm(1,"Lin",900,1)) # fit model

# vgm() list of models

plot(dt.vgm, dt.fit)


lzn.kriged <- krige((z) ~ 1, remove.duplicates(DT_sf), grd_sf, model=dt.fit) #remove duplicate locations

lzn.kriged %>% as.tibble %>% rename(lon=coords.x1, lat=coords.x2) %>% 
  ggplot(aes(x=lon, y=lat)) + geom_tile(aes(fill=var1.pred)) +coord_equal() +
  scale_fill_viridis_c() +
  labs(title = "height of network across the  UK")

lzn.kriged %>% as.tibble %>% rename(lon=coords.x1, lat=coords.x2) %>% 
  ggplot(aes(x=lon, y=lat, colour = var1.pred)) +geom_point() +  scale_colour_viridis_c()



kriged_df <- lzn.kriged %>% as.tibble %>%
  rename(Z = var1.pred) %>%
  select(-var1.var) %>%
  rename(x = coords.x1, y = coords.x2)

Krig_spatial_points <- st_as_sf(kriged_df, coords = c("x", "y"), crs = "+proj=longlat +datum=WGS84", agr = "constant")
kept_points <- st_intersection(st_as_sf(spdf), Krig_spatial_points) %>% as.data.frame()

{
kriged_df2 <- kriged_df %>%
  spread(key = x, value = Z, fill = NA) 

x <- names(kriged_df2)[-1]  %>% as.numeric()
y <- kriged_df2 %>% pull(y)

kriged_df2 <- kriged_df2 %>%
  select(-y) %>% as.matrix()
}

plot_ly(x=x,y=y,z=kriged_df2, type="surface")

library(rgl)
persp3d(unique(as.numeric(kriged_df$x)) %>% sort, unique(kriged_df$y) %>% sort, kriged_df, col="skyblue")





```


#plotly
```{r}
x <- 1:5/10
y <- 1:5
z <- x %o% y
z <- z + .2*z*runif(25) - .1*z

library(plotly)
plot_ly(x=x,y=y,z=z, type="surface")

```

