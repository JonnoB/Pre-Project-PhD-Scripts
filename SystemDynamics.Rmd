---
title: "Untitled"
author: "Jonathan Bourne"
date: "22 March 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

https://github.com/schochastics/graphlayouts

https://github.com/hackl/tikz-network


some IEEE datasets
https://icseg.iti.illinois.edu/power-cases/

annpotate points with rectangles
https://ggforce.data-imaginist.com/reference/geom_mark_rect.html

#Set up
```{r Setup}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "stringr", "xtable", "rlang", "animation", "caret", "sf", "rgdal", "sf", "gstat", "automap", "rayshader", "latex2exp", "yardstick", "minpack.lm", "gganimate")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

#ggtree needs to be installed seperatly 
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("ggtree", version = "3.8")
#devtools::install_github("eliocamp/ggnewscale@v0.1.0")
#devtools::install_github("eliocamp/ggnewscale")

# library(ggtree)
# library(ape)
# library(ggnewscale)


sapply(packages, library, character.only = TRUE)

library(PowerGridNetworking)

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Physics model for analysing flow graphs" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Tariff <- file.path(basewd,"Tariff and Transport")
PLwd <- "/media/jonno/Seagate Expansion Drive/System_Dynamics"
Deletion_Order_Folder <-  file.path("/home/jonno/Dropbox/AWS_Simulation_Files") #Only one of the deletion order folders is needed. Either Nodes or Edges
IEEE_Project_folder <- "/media/jonno/Seagate Expansion Drive/IEEE_Networks"

#Load necessary datasets and great the base powergrid network
source(file.path("/home/jonno/ProportionalLoading", "CreateGBase.R"))

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))

list.files("/home/jonno/Flow_Spring_System", pattern = ".R", full.names = T) %>%
  walk(~source(.x))

VertexMetaData2 <- VertexMetaData %>%
  mutate(NodeType = case_when(
    BalencedPower>0 ~"Generator",
    BalencedPower< 0~"Demand",
    TRUE ~ "Transfer"
  ),
  NodeType2 = case_when(
    Demand>0 & Generation>0 ~"Hybrid",
    TRUE ~ NodeType
  )) %>% select(Name, NodeType, NodeType2, BalencedPower)

```


#Psychadelic beard/boat

This plots the strain values of a 4 node three edge graph with a constant EC and varying alpha. It shows that strain is more expressive than either alpha, ec or a combination of the two

The code giveing the animation that shows convergence has been lost. The animation is pretty helpful so it is a good idea to do it again.
```{r}

#The function that calculate the force from the angle
ForceV_from_angle <- function(target_angle, k, d){
  #allows us to tune an angle to get a specific force. alternatively we can tune k and d!
  tibble(H = sqrt(d^2 * (1 + tan(target_angle)^2)),
         ForceT = k*(H-d), 
         ForceV = ForceT*sin(target_angle)) %>%
    pull(ForceV)
  
}

#Get all the possible combinations of each edge excluding height data
fixed_mean_alpha  <- 20:80 %>%
  map_df(~{
     BranchEC <-100-.x -20
    
     tibble(A = .x,
           B =10 + BranchEC*(0:100)/100,
           C = 10 +  BranchEC*(100:0)/100,)
    
  } ) %>%
  mutate(groupID = 1:n()) %>%
  gather(key = edge, value = capacity, - groupID) %>%
  left_join(tibble(edge = c("A", "B", "C"), 
                   flow = c(20,10,10)), #edge flow is always postive! 
            by = "edge") %>%
  mutate(alpha = capacity/abs(flow)) %>%
  group_by(groupID) %>%
  mutate(mean_alpha = mean(alpha), 
         flow_fract = abs(flow)/sum(ifelse(flow>0,flow,0)),
         excess_cap = sum(alpha*flow_fract)/3) %>%
  group_by(mean_alpha) %>%
  mutate(counts = n(),
         k = 100*(10-1)*(1-1/alpha)+100,
         rank = rank(excess_cap, ties.method = "random")) %>% 
  ungroup 

#Minimise the data down to only the usefully distinct data
Edge_combos <- fixed_mean_alpha  %>%
  distinct(alpha, flow, .keep_all = TRUE) %>%
  mutate(groupID2 = 1:n())

#Calculate heights for each node pair combination
Edge_combos_delta_z <- Edge_combos$groupID2  %>% 
  map_df(~{  
    if((.x/100)%%1 == 0){ (print(.x))} #print every 100
    
    current_settings <- Edge_combos   %>%
      filter(groupID2 == .x)
    
    solution_angle <- nlsLM(Force ~ ForceV_from_angle(target_angle, k = k, d = 1), 
                            start = c(target_angle = pi/4), 
                            data = list(Force = current_settings$flow, k = current_settings$k), 
                            upper = pi/2)
    
    
    Out <- current_settings %>%
      mutate( theta_rads = coef(solution_angle)[1],
              theta_degs = theta_rads*360/(2*pi),
              delta_z = tan(theta_rads),
              delta_h = sqrt(delta_z^2 + 1)-1,
              strain = delta_z # this is because the distance is 1 and strain = (H-d)/d and H = delta_h+d
      ) %>%
      select(groupID, theta_rads, theta_degs, delta_z, flow, alpha, k, delta_h, strain)
  })  

#calculate the ratio of excess capacity split between B and C then join with the alpha value by group
  toy_theta_temp <-  fixed_mean_alpha %>%
  select(groupID, edge, alpha, counts) %>%
  spread(key = edge, value = alpha) %>%
  mutate(
    B= 1/B,
    C = 1/C,
    ratio = (B)/(C+B)) %>%
  left_join(fixed_mean_alpha %>%
  select(groupID, mean_alpha) %>%
    distinct) %>%
    select(-A, -B, -C)

#get combine the previous df's together to get the angle across the system for all combinations
toy_height_data <- fixed_mean_alpha %>%
select(groupID, edge, flow, alpha) %>%
  #add in the height data
  left_join(Edge_combos_delta_z %>% select(-groupID))  %>%
  select(groupID, edge, strain) %>%
  #Use spread to keep the delta values for each edge
  spread(key = edge, value = strain) %>%
  mutate(mean_strain = (A+B+C)/3) %>%
  left_join(toy_theta_temp, by = "groupID")


  toy_height_data %>%
    # some of the mean_alpha values are seperating on machine tolerance or something
        mutate(mean_alpha = signif(mean_alpha,5)) %>% 
    #filter(mean_alpha <=2.5) %>%
    ggplot(aes(x = ratio, y = mean_strain, colour = mean_alpha, group = mean_alpha)) + 
    geom_line(size = 1) +
    scale_colour_viridis_c() +
    labs(title =latex2exp::TeX(paste("The relationship between strain and ", 
                                     "$\\alpha \\,$", 
                                     " in terms of ec fraction in edge B" )), 
         y = "system strain", 
         x= latex2exp::TeX("$\\frac{ec_{B}}{ec_{B}+ec_{C}}$"),
         colour = latex2exp::TeX(paste("system", "$\\alpha$")))
  ggsave(file.path(FiguresFolder, "Constant_excess_capacity.pdf"))

"Relationship between alpha, excess capacity and theta"
```

##Entropic degree
```{r}

entropy_data<- fixed_mean_alpha %>%
  group_by(groupID) %>%
  mutate(p_capacity = capacity/sum(capacity),
         p_alpha = alpha/sum(alpha),
         entrop_capacity = -p_capacity*log(p_capacity),
         entrop_alpha = -p_alpha*log(p_alpha)) %>%
  summarise(capacity = sum(entrop_capacity),
            alpha = sum(entrop_alpha)) %>%
  #normalise the entropy relative to the highest value
  mutate(capacity = capacity/max(capacity), 
         alpha = alpha/max(alpha))

toy_height_data %>%
  select(groupID, mean_strain, mean_alpha) %>%
  left_join(entropy_data) %>%
  gather(key = type, value = div, -mean_strain, - mean_alpha,-groupID ) %>%
    mutate(mean_alpha = signif(mean_alpha,5)) %>%  # some of the mean_alpha values are seperating on machine tolerance or something
  ggplot(aes(x = div, y = mean_strain, colour = mean_alpha, group = mean_alpha)) + 
  geom_line(size = 1) +
  scale_colour_viridis_c() +
  facet_grid(~type) +
  labs(title = latex2exp::TeX(paste("Exploring the relationship between strain", 
                                    ",", 
                                    "$\\alpha$", "and entropy")), 
       x = "Normalised entropy", 
       y ="system strain", 
       colour =  latex2exp::TeX(paste("system", "$\\alpha$")))
ggsave(file.path(FiguresFolder, "entropy_theta.pdf"))

rm(entropy_data)
```

##The square
```{r}

alpha_values <- c(1,Inf, 1.05, 1.1, 2, 5)

edge_alpha <- expand.grid(AB_alpha =alpha_values, AC_alpha =alpha_values, BD_alpha =alpha_values, CD_alpha =alpha_values) %>% 
  as_tibble  %>%
  mutate(ID = 1:nrow(.),
         alpha = (AB_alpha+AC_alpha+BD_alpha+CD_alpha)/4,
         capacity = (AB_alpha*15+AC_alpha*15+BD_alpha*5+CD_alpha*5) ) 
%>%
  filter(AB_alpha >=AC_alpha)

grid_search_alpha <- 1:nrow(edge_alpha) %>% map_df(~{
  #set up graph
square_g <- tibble(from = c("A", "A", "B", "C"), 
                   to = c("B","C", "D", "D"), 
                   Link = paste0(from, to),
                   flow = c(15,15,5,5),
                   alpha = edge_alpha[.x,1:4] %>% as.numeric(), #545 is a good choice of row for testing
                   capacity = flow*alpha) %>%
  graph_from_data_frame(directed = FALSE)

#addin missing attributes
 square_g2 <-set.vertex.attribute(square_g, "Generation", value = c(30,-10,-10,-10))%>%
   set.edge.attribute(., "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., Force = "flow", Capacity = "capacity", 400, 40) %>%
    set.edge.attribute(., "Area", value = 1)

  #this needs to be normalised

#find equilibrium
 ptm <- proc.time()
 Square_heights <- Find_network_balance(square_g2, force = "Generation",
                                        flow = "flow",
                                        capacity = "capacity",
                                        tstep = 0.001, tol = 1e-10, distance = "distance", 
                                        maxIter = 4000, mass = 1)

# Stop the clock
elapsed_time <-proc.time() - ptm
#add iteration number and return
 Out <- Square_heights$NodeList %>%
   mutate(ID = .x,
          elapsed_time = elapsed_time[3])
 
 return(Out)
 
 })
 
write_rds(grid_search_alpha,file.path(PLwd, "grid_search_alpha.rds"))

 Square_heights$results %>%
   ggplot(aes(x = t, y = z)) + geom_line()
   
 grid_search_alpha %>%
  ggplot(aes(x = z, colour = node)) + geom_density() +
   labs(title = "Density of node height for the square graph")
 
test <- grid_search_alpha %>% as_tibble %>%
  select(node, z, ID) %>%
  spread(key = node, value = z) %>%
   mutate(AB_strain = sqrt((A-B)^2+1)-1,
          AC_strain = sqrt((A-C)^2+1)-1,
          BD_strain = sqrt((B-D)^2+1)-1,
          CD_strain = sqrt((C-D)^2+1)-1,
          strain = (AB_strain+AC_strain+BD_strain+CD_strain)/4) %>%
   left_join(edge_alpha) %>%
  mutate(joint = paste(alpha, capacity))

test2 <- test %>%
  group_by(joint) %>%
  summarise(counts = n(),
            strain_max = max(strain),
            strain_min = min(strain)) %>%
  mutate(diff = strain_max-strain_min)

strain_sum = test %>%
  mutate(strain = round(strain, 5)) %>%
 # filter(strain ==0.01006)
  group_by(strain, joint) %>%
  summarise(counts = n())

test %>%
 # filter(alpha<1.2) %>%
  ggplot(aes(colour = strain, y = alpha, x = (capacity), group = alpha)) +geom_point() +
  scale_color_viridis_c()


test2<- test %>%
  filter(#capacity<50,
         alpha<1.2)

```


##Convergance visualisation
```{r}

```


#IEEE118

This section uses the IEEE_118 network to demonstrate that strain is a proxy for the robustness of the network under random attack.

##plot IEEE118

```{r}
IEEE_Project_folder <- "/media/jonno/Seagate Expansion Drive/IEEE_Networks"

IEEE_118 <- readRDS(file.path(IEEE_Project_folder,"IEEE_network_files", "IEEE_118_igraph.rds"))


#set node coordinates for IEEE118
set.seed(2664)
IEEE118_heights <- IEEE_118 %>%
    as_data_frame(.) %>%
    select(from, to, Link, PowerFlow) %>%
    gather(key = "type", value = "Node",-Link,-PowerFlow) %>%
  left_join(layout_with_fr(IEEE_118) %>% 
    as_tibble %>% 
    mutate(Node = names(V(IEEE_118)))) %>%
  left_join(as_data_frame(IEEE_118, what = "vertices") %>%
  rename(Node = name)) %>%
  mutate(type = case_when(
    Net_Generation>0~"Generator",
    Net_Generation<0~"Demand",
    TRUE~"Transfer"
  )
  ) %>%
  left_join(., list.files(file.path(IEEE_Project_folder, "Solved_height_networks"), full.names = TRUE)[16] %>%
  read_rds(), by = c("Node"="node")
  ) %>%
  mutate(height_perc = percent_rank(z))


#The shortest path code is no longer necessary
#extrema <- IEEE118_heights %>%
#  filter(z %in% c(max(z), min(z)))

#nodes_shortest_path <- shortest_paths(IEEE_118, from = "10", to = "112", output = "vpath", weights = NA)[[1]] %>% unlist %>%
#  get.vertex.attribute(IEEE_118, index = .) %>% .$name

#Plot IEEE118 with fruchtman reingold expansion 
IEEE118_heights %>%
  ggplot(aes(x = V1, y = V2, group = Link)) + 
  geom_line() + #aes(colour = abs(PowerFlow)) 
 # geom_line(data = IEEE118_heights %>% filter(Node %in% nodes_shortest_path), colour = "red")+
  geom_point(aes(colour = height_perc, shape = type ), size =3)+
  labs(title = "IEEE118 power flow and node type, using Fruchtman Reingold expansion",
       shape = "Node type",
       colour = "Height Percentile") +
  scale_colour_viridis_c() +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank())
  ggsave(file.path(FiguresFolder, "IEE118_map.pdf"))
```


###normalising the load

This function allows the node power and edge capacities to be normalised to allow easier comparison across networks.
```{r}


test <- Proportional_Load(IEEE_118, alpha = 3, Link.Limit = "Link.Limit") %>%
  Normalize_load(., EdgeName = Link, VertexName = name, Net_Generation = Net_Generation, capacity = Link.Limit)

test2 <-  Normalize_load(g, EdgeName = Link, VertexName = name, Net_Generation = BalencedPower, capacity = Link.Limit,
                         Generation = Generation, Demand = Demand)


```


##Strain alpha relationship

```{r}
target_orders  <- readRDS(file.path(IEEE_Project_folder, "target_orders.rds"))

IEEE_118_dist <- IEEE_118 %>%
  set.edge.attribute(., "distance", value = 1)%>%
  set.edge.attribute(., "Link.Limit", value = Inf)

IEEE_theta_by_alpha <- list.files(file.path(IEEE_Project_folder, "Solved_height_networks"), full.names = TRUE) %>%
  map_df(~{
    read_rds(.x) %>%
    Calc_line_strain(IEEE_118_dist , ., distance = distance) %>%
      summarise(theta_degs = mean(strain)) %>%
    #angle_from_solved_heights(.) %>%
    mutate(alpha = basename(.x),
           )  
  }) %>%
  mutate(alpha = gsub("IEEE_118_alpha_", "", alpha) %>%
           gsub(".rds", "",.) %>% as.numeric())

IEEE_theta_by_alpha_ec <- list.dirs(file.path(IEEE_Project_folder,"constant_ec_from_alpha"), recursive = FALSE) %>%
  map_df(~{
    Out <- list.files(.x, full.names = TRUE) %>%
      map_df(~{
        read_rds(.x) %>%
    Calc_line_strain(IEEE_118_dist , ., distance = distance) %>%
      summarise(theta_degs = mean(strain)) %>%
    #angle_from_solved_heights(.) %>%
          mutate(alpha = basename(.x))  
      }) %>%
      rename(v = alpha) %>%
      mutate( ec = basename(.x) %>% gsub("Solved_height_networks_alpha_", "", .),
              v = gsub("IEEE_118_v_", "", v) %>%
                gsub(".rds", "",.) %>% as.numeric )%>% 
      arrange(v) #%>% 
     bind_cols(target_orders) #This is the target orders from the IEEE script
    
    return(Out)
    
  })
```


##load all sims and find critical threshold

Data loaded from Create_IEEE_networks.Rmd

##Extract Nodes version
```{r}

critical_threshold <- function(g){
  #finds the critical threshold according to the molly reed criterion
  node_degree <-degree(g)
  k2_over_k <- mean(node_degree^2)/mean(node_degree)
  
  Out <- 1- 1/(k2_over_k-1)
  
  return(Out)
}


critical_threshold2 <- function(g){
  #finds the critical threshold according to the molly reed criterion
  node_degree <-degree(g)

    Out <- (mean(node_degree^2) - 2*mean(node_degree))>0

  return(Out)
}


#perc of nodes that need to be removed to lose giant component
critical_threshold(IEEE_118)

#remaining nodes
IEEE_118_critical <- round(118- critical_threshold(IEEE_118)*118, 0)

#Proportional loading
ExtractAttackStats(file.path(IEEE_Project_folder, "IEEE118"), 
                   file.path(IEEE_Project_folder, "SummaryData"),
                   Generation = "Net_Generation",
                   EdgeName = "Link")



list.dirs(file.path(IEEE_Project_folder,"IEEE_permute_edge_ec"), recursive = F) %>%
  walk(~{
    
    #scrambled edges alpha 2
    ExtractAttackStats(.x, 
                       file.path(IEEE_Project_folder, "SummaryData_ec_alpha_2", basename(.x)),
                       Generation = "Net_Generation",
                       EdgeName = "Link")
    
  })

#scrambled edges alpha 2
ExtractAttackStats(file.path(IEEE_Project_folder, "IEEE1118_const_ec"), 
                   file.path(IEEE_Project_folder, "SummaryData_ec_alpha_2"),
                   Generation = "Net_Generation",
                   EdgeName = "Link")



AttackRoundData <- list.files(path = file.path(IEEE_Project_folder,"SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x))   %>%
  arrange(-TotalNodes) %>%
  filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
  mutate(alpha = gsub("alpha_value_", "", alpha) %>% 
           as.numeric()/100)



AttackRoundData_ec_alpha_ec <- list.dirs(file.path(IEEE_Project_folder,"SummaryData_ec_alpha_2"), recursive = F) %>%
  map_df(~{
    
    list.files(.x, full.names = TRUE) %>%
      map_df(~read_rds(.x))     %>%
  arrange(-TotalNodes) %>%
  filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
      mutate(alpha_class = basename(.x))
    
  }) %>%
  group_by(alpha, alpha_class) %>%
  summarise(NodesAttacked = mean(NodesAttacked)) %>%
  ungroup %>%
  mutate(v = alpha %>% gsub("constant_ec_v", "", .) %>%
           as.numeric(.),
         ec = alpha_class %>% gsub("alpha_value_", "", .) %>%
           as.numeric(.)/100) %>%
  select(-alpha) %>%
  left_join(target_orders, by = c("ec", "v"))





```

##Extract Edges version
```{r}

#Proportional loading
ExtractAttackStats(file.path(IEEE_Project_folder, "IEEE118_edges"), 
                   file.path(IEEE_Project_folder, "SummaryData_edges_attack"),
                   Generation = "Net_Generation",
                   EdgeName = "Link")



list.dirs(file.path(IEEE_Project_folder,"IEEE_permute_edge_ec_Edge"), recursive = F) %>%
  walk(~{
    
    #scrambled edges alpha 2
    ExtractAttackStats(.x, 
                       file.path(IEEE_Project_folder, "SummaryData_ec_alpha_2_Edge", basename(.x)),
                       Generation = "Net_Generation",
                       EdgeName = "Link")
    
  })


AttackRoundData <- list.files(path = file.path(IEEE_Project_folder,"SummaryData_edges_attack"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x))   %>%
  arrange(-TotalNodes) %>%
  mutate(has_gc = mean_degree_sqrd > 2*mean_degree) %>%
  filter(!has_gc) %>%
  #filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
  mutate(alpha = gsub("alpha_value_", "", alpha) %>% 
           as.numeric()/100)


AttackRoundData_ec_alpha_ec <- list.dirs(file.path(IEEE_Project_folder,"SummaryData_ec_alpha_2_Edge"), recursive = F) %>%
  map_df(~{
    
    list.files(.x, full.names = TRUE) %>%
      map_df(~read_rds(.x))     %>%
  arrange(-TotalNodes) %>%
  mutate(has_gc = mean_degree_sqrd > 2*mean_degree) %>%
  filter(!has_gc) %>%
  #filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
      mutate(alpha_class = basename(.x))
    
  }) %>%
  group_by(alpha, alpha_class) %>%
  summarise(NodesAttacked = mean(NodesAttacked)) %>%
  ungroup %>%
  mutate(v = alpha %>% gsub("constant_ec_v", "", .) %>%
           as.numeric(.),
         ec = alpha_class %>% gsub("alpha_value_", "", .) %>%
           as.numeric(.)/100) %>%
  select(-alpha) %>%
  left_join(target_orders, by = c("ec", "v"))

```


##plot scramble results
```{r}
relative_position <- function(strain_vect, ref_strain_vect){
  #this function finds the relative fraction of strain compared to the absolute max and min values of that parameter
  #strain_vect a numeric value of the mean strain of a network
  #ref_strain_vect a vector of values of at least two inclduing the strain in the network when k = c and k = RC
  (strain_vect-min(ref_strain_vect))/(max(ref_strain_vect)-min(ref_strain_vect))
  
}

#get the mean number of edges attacked per line loading alpha
theta_crit_thresh <- AttackRoundData %>%
  group_by(alpha) %>%
  summarise_all(mean) %>%
  left_join(IEEE_theta_by_alpha) %>%
  mutate(alpha = 1/alpha,
         orig_strain = theta_degs,
     theta_degs =   relative_position(theta_degs, IEEE_theta_by_alpha$theta_degs) 
     ) %>%
  mutate(true_alpha = 1/alpha)

#get the mean number of elements attacked for each of the hundred random attacks per scramble
theta_crit_thresh_ec_2 <- AttackRoundData_ec_alpha_ec  %>%
  left_join(IEEE_theta_by_alpha_ec %>% 
              mutate(ec = ec %>% as.numeric(.)/100)) %>%
  mutate(alpha = 1/alpha,
                  orig_strain = theta_degs,
         theta_degs =  relative_position(theta_degs, IEEE_theta_by_alpha$theta_degs)
         )

#reshape so that the alpha and strain values can be plotted
{
PropLoad_line <- theta_crit_thresh %>%
  select(alpha, NodesAttacked, theta_degs) %>%
  gather(key = type, value = value, -NodesAttacked) 
  
 PropLoad_line <-  bind_rows(PropLoad_line %>%
  mutate(type = ifelse(type=="alpha" , "alpha[sys]", "1/kappa~strain"), 
         bounded = FALSE),
  PropLoad_line %>% 
  mutate( type = ifelse(type=="alpha" , "1/alpha[sys]", "kappa~strain"), 
          value = 1/value,
          bounded = TRUE)) %>%
   mutate(type = factor(type, levels = c("1/alpha[sys]", "kappa~strain", "alpha[sys]", "1/kappa~strain")))

#reshape so that the alpha and strain values can be plotted

 scrambled_ec_points <- theta_crit_thresh_ec_2 %>%
               select(alpha, NodesAttacked, theta_degs, ec, v) %>%
               gather(key = type, value = value, -NodesAttacked, -ec, -v) %>%
  mutate(ec = factor(ec)#,
         #type = type %>%factor(., labels = c("1/alpha[sys]", "kappa~strain"))
         ) %>%
  mutate(alpha_limit = case_when(
    v == 1~ "min",
    v == 10~"max",
    TRUE ~"0ther"
  ))

  scrambled_ec_points <-  bind_rows(scrambled_ec_points %>%
  mutate(type = ifelse(type=="alpha" , "alpha[sys]", "1/kappa~strain"),
          bounded = FALSE),
  scrambled_ec_points %>% 
  mutate( type = ifelse(type=="alpha" , "1/alpha[sys]", "kappa~strain"), 
          value = 1/value,
          bounded = TRUE)) %>%
   mutate(type = factor(type, levels = c("1/alpha[sys]", "kappa~strain", "alpha[sys]", "1/kappa~strain")))

 
}

#plot the data to show that the strain value has a closer relationship to the proportional load than the alpha value does for both high and low values of strain.
PropLoad_line %>%
  filter(bounded) %>%
  ggplot(aes(y = 1/value, x = NodesAttacked)) + 
  geom_path() +
 # geom_line(data = scrambled_ec_points, aes(group = factor(v), colour = ec)) +
  geom_point(data = scrambled_ec_points  %>%
  filter(as.character(ec)%>% as.numeric()<30) %>% filter(bounded),# %>%  filter(ec !=100),
             aes(colour = ec)) +
  facet_wrap(~type, labeller = label_parsed) + #parsing shows the plotmath
  labs(title = "Analysing the spread of outcomes for mean loading and relative strain", 
       x = "Edges Attacked", y = "metric value") 
#scale_colour_viridis_c()+
ggsave(file.path(FiguresFolder, "NodesAttacked_Strain_alpha_small_ec_118.pdf"))

PropLoad_line %>%
  filter(!bounded) %>%
  ggplot(aes(y = 1/value, x = NodesAttacked)) + 
  geom_path() +
 # geom_line(data = scrambled_ec_points, aes(group = factor(v), colour = ec)) +
  geom_point(data = scrambled_ec_points  %>%
  filter(as.character(ec)%>% as.numeric()<30) %>% filter(!bounded),# %>%  filter(ec !=100),
             aes(colour = ec)) +
  facet_wrap(~type, labeller = label_parsed) + #parsing shows the plotmath
  labs(title = "Analysing the spread of outcomes for alpha and one over relative strain", 
       x = "Edges Attacked", y = "metric value") +
  coord_cartesian(ylim = c(0,200))
ggsave(file.path(FiguresFolder, "NodesAttacked_Strain_alpha_large_ec_118.pdf"))

#This shows that the extrema from each group act as a boundary to the scrambled loads
PropLoad_line %>%
  filter(bounded) %>%
  ggplot(aes(y = 1/value, x = NodesAttacked)) + 
  geom_path() +
 # geom_line(data = scrambled_ec_points, aes(group = factor(v), colour = ec)) +
  geom_point(data = scrambled_ec_points %>%  filter(bounded),
             aes(colour = alpha_limit)) +
  facet_wrap(~type, scales = "free", labeller = label_parsed) + #parsing shows the plotmath
  labs(title = "Comparing strain for different alpha and excess capacity levels", 
       y = "Edges Attacked") 

```


#UK map 

##Set up UK Graph
```{r}

g <- RemoveDeadEnds(gbase) #remove non-valid ends from the graph
#Ensure there is powerflow
SlackRef <- SlackRefFunc(g) #find the most appropriate node to be the slack bus
g <- PowerFlow(g, SlackRef$name) #calculate power flow

```

Shoe that there is low corellation betweeen line strain and alpha

```{r}

#create a sub graph that includes all the bicomponent of a node except the one that includes the active bi-comp

if(file.exists(file.path(PLwd, "UK_power_grid_3d.rds"))){
  final_z <- read_rds(file.path(PLwd, "UK_power_grid_3d.rds"))
} else{
  
  g2 <-set.edge.attribute(g, "Imp", value = 1/get.edge.attribute(g, "Y"))
  g2 <-set.edge.attribute(g2, "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", minimum_value = 100, stretch_range = 1000) %>%
    set.edge.attribute(., "Area", value = 1)
  g2 <-Normalize_load(g2, EdgeName = Link, VertexName = name, Net_Generation = BalencedPower, capacity = Link.Limit,
                         Generation = Generation, Demand = Demand)
  
  List_of_BiConComps <- Create_balanced_blocks(g2, force = "BalencedPower")
  
test <- 1:length(List_of_BiConComps) %>% map_df(~{
  compo <- List_of_BiConComps[[.x]] 
  
  #component 83 is the only block where there is no demand
  compo %>% get.vertex.attribute(., "BalencedPower") %>% sum %>%
    tibble(comp = .x, resid = ., nodes = vcount(compo), edges = ecount(compo), 
           min = min(get.vertex.attribute(compo, "BalencedPower"))^2, #find closest to 0
           max = max(get.vertex.attribute(compo, "BalencedPower")))
  })
  
  #use the largest block to set the simulation parameters k and m.
  #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
OriginBlock <- Find_network_balance(List_of_BiConComps[[147]], tstep = 0.05, tol = 1e-10, distance = "distance", 
                                      maxIter = 10000, mass = 1)

final_z <- Create_stabilised_blocks(g2, OriginBlock, 147, tstep = 0.01, tol = 1e-10, 
                                      distance = "distance", maxIter = 20000, mass = 1)
  
  write_rds(final_z, file.path(PLwd, "UK_power_grid_3d.rds"))
  
}


#Is the strain power law distributed?
line_strain <-set.edge.attribute(g, "distance", value = 1) %>%
  Calc_line_strain(., final_z, distance)

cor(line_strain$dz, line_strain$strain)
cor(line_strain$line_load, line_strain$strain)

z_network_map <-MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
  left_join(line_strain, by = c("Link"))%>%
   left_join(., final_z %>% select(node, z), by = c("Node"= "node")) 

z_network_map %>%
  #filter(!is.na(Perc)) %>%
    ggplot(aes(x = Longitude, y = Latitude)) + 
  geom_line(aes(group = Link, colour = percentile_strain), size = 0.8) + 
   facet_grid(~PositionType) + 
 # geom_point( aes(x = Latitude, y = Longitude, colour = percent_rank(z))) + 
  scale_color_viridis_c()+
  ggtitle("Strain map")


test <- node_height_edge_strain(set.edge.attribute(g, "distance", value = 1), 
                  final_z, 
                  MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
                    filter(PositionType=="Geo Space"), distance)

test2 <- test$edge_strain


node_z <-z_network_map %>% as_tibble %>%
  filter(PositionType=="Geo Space") %>%
  select(Node, Longitude, Latitude, z) %>%
  distinct(.keep_all = T) 

#only used for edge voronoi
# edge_z <-z_network_map %>% as_tibble %>%
#   filter(PositionType=="Geo Space") %>%
#   select(Longitude, Latitude, z, Link) %>%
#   group_by(Link) %>%
#   summarise_all(mean)

#This is the strain of the network on each edge. It allows us to see the slope of the network
edge_strain <- z_network_map %>% as_tibble %>%
  filter(PositionType=="Geo Space") %>%
  select(Longitude, Latitude, z = strain, Link) %>%
  group_by(Link) %>%
  summarise_all(mean)


#Find the shortest path between the highest and lowest points
 extrema <- node_z %>%
  filter(z %in% c(max(z), min(z)))

nodes_shortest_path <- shortest_paths(g, from = "GRUB", to = "INDQ", output = "vpath", weights = NA)[[1]] %>% unlist %>%
  get.vertex.attribute(g, index = .) %>% .$name

nodes_shortest_path_df <- z_network_map %>%select(-type) %>%
  filter(PositionType=="Geo Space", 
         Node %in% nodes_shortest_path)

node_z2 <- node_z %>%
  left_join(VertexMetaData %>% rename(Node = Name)) %>%
  #all of this is to find the mid point
  arrange(Latitude) %>%
  mutate(lat_cumsum = cumsum(ifelse(BalencedPower>0, BalencedPower, 0)),
         lat_rev_cumsum = rev(lat_cumsum),
         lat_diff = lat_cumsum - lat_rev_cumsum,
         lat_abs_diff = abs(lat_diff)) %>%
    arrange(Longitude) %>%
  mutate(lon_cumsum = cumsum(ifelse(BalencedPower>0, BalencedPower, 0)),
         lon_rev_cumsum = rev(lon_cumsum),
         lon_diff = lon_cumsum - lon_rev_cumsum,
         lon_abs_diff = abs(lon_diff))  %>%
  arrange(Latitude) %>% 
  mutate(mass = 1) %>%
  mutate(mass_lat_cumsum = cumsum(mass),
         mass_lat_rev_cumsum = rev(mass_lat_cumsum),
         mass_lat_diff = mass_lat_cumsum - mass_lat_rev_cumsum,
         mass_lat_abs_diff = abs(mass_lat_diff)) %>%
    arrange(Longitude) %>%
  mutate(mass_lon_cumsum = cumsum(mass),
         mass_lon_rev_cumsum = rev(mass_lon_cumsum),
         mass_lon_diff = mass_lon_cumsum - mass_lon_rev_cumsum,
         mass_lon_abs_diff = abs(mass_lon_diff))

```

##UK network plot
```{r}
shapefile <- file.path("/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ShapeFiles UK",
                       "Countries_December_2017_Ultra_Generalised_Clipped_Boundaries_in_UK_WGS84.shp")

GB <- st_read(shapefile) %>%
  filter(ctry17cd !="N92000002") %>%
  st_union()

#plots the uk network with the shortest path between the highest and lowest points as well as the midpoint
ggplot(GB) +
  geom_sf() +
 # scale_fill_viridis("Area") +
  ggtitle("Node locations in the UK") +
 # theme_bw() +
  geom_line(data = z_network_map %>%
              filter(PositionType=="Geo Space"),  aes(x = Longitude, y = Latitude, group = Link)) +
   geom_point(data =node_z, aes(x = Longitude, y = Latitude, colour = z), alpha  = 0.7)+
  coord_sf(ylim = c(50,58.9)) +
    geom_line(data = nodes_shortest_path_df,
            aes(x = Longitude, y = Latitude, group = Link),
            colour = "red") +
  scale_color_viridis_c() +
  geom_point(data = node_z2 %>% filter(lat_abs_diff== min(lat_abs_diff)),
             aes(x = Longitude, y = Latitude), 
             colour = "red") +
    geom_point(data = node_z2 %>% filter(lon_abs_diff== min(lon_abs_diff), Generation>0),
             aes(x = Longitude, y = Latitude), 
             colour = "cyan") +
  geom_hline(aes(yintercept = node_z2 %>% filter(Node == "BLAC") %>% pull(Latitude)), colour = "red") +
    geom_hline(aes(yintercept = node_z2 %>% filter(Node == "MOFF") %>% pull(Latitude)), colour = "red")+
    geom_vline(aes(xintercept = node_z2 %>% filter(Node == "CONQ") %>% pull(Longitude)), colour = "cyan") 
```


##Kriging
```{r}

spdf <- as(GB, "Spatial") %>% st_as_sf %>%
  st_crop(c(xmin = -7.5, ymin = 50, xmax = 2, ymax = 59)) %>%
  as_Spatial()

kriged_height_strain_data <- krige_height_strain_maps(set.edge.attribute(g, "distance", value = 1), 
                                                      final_z, 
                                                      MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
                                                        filter(PositionType=="Geo Space"), distance,
                                                      spdf)

kriged_height_strain_data %>%
  ggplot(aes(x=Longitude, y=Latitude)) + 
  geom_tile(aes(fill=Height)) + coord_equal() +
  facet_grid(~type) +
  scale_fill_viridis_c() +
scale_colour_viridis_c(option = "plasma") +
  labs(title = "Height and Strain of the UK high-voltage power grid 
       after converting to a system of springs", fill = "Percentile") +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "right") #the legend position may want changing back to the more convential side.
  ggsave(file.path(FiguresFolder, "BritainKrigedTopology.pdf"))


```

#Generating profiles

look at grid strain using different generating profiles.

the carbon intensity data comes from 
https://www.ipcc.ch/report/renewable-energy-sources-and-climate-change-mitigation/
```{r}

Generator_details <-GenerationData %>% 
  select(Node = Site, Station, Generator.Type, Max_power = "Max.Contracted.TEC.at.Peak..Transport.Model.TEC.",
         Base_power = "Generation.Base....Tariff.Model.TEC.",
         Carbon_type = "Carbon...Low.Carbon") %>%
  filter(!is.na(Node), Max_power>0) #get rid of nodes without generation
  
test %>%
  group_by(Carbon_type) %>%
  summarise(Max_power = sum(Max_power),
            Base_power = sum(Base_power))

#uses 50th percentile data
Carbon_intensity <-tibble(Generator.Type = c("Biomass", "CCGT", "Coal", "CHP", "Hydro", "Interconnectors", "Nuclear", "OCGT", "Pump Storage", "Tidal", "Wind Offshore", "Wind Onshore"),
      Carbon_intensity = c(18, 496, 1001, 469, 4, 68, 16, 469, 4, 8, 12, 12),
       value_type = c("IPCC", "IPPC", "IPPC", "Gas IPPC", "IPPC", "electrictymap.org france average", "IPCC", "IPCC", "Hydro level as it uses spare capcity for max efficiency", "IPCC","IPCC", "IPCC"))

Generator_details %>%
  group_by(Generator.Type) %>%
  summarise(Max_power = sum(Max_power),
            Base_power = sum(Base_power),
            Carbon_type = first(Carbon_type)) %>%
  left_join(., Carbon_intensity) %>%
  arrange(Carbon_intensity)  %>%
  mutate(Per_tot = Max_power/sum(Max_power)*100,
          Per_Dem = Max_power/sum(trans1$Demand)*100,
         cum_sum = cumsum(Max_power))
  
```

##profile function
```{r}
create_profile_g <- function(simulation_power, VertexMetaData, g){
  
  Profile_VertexMetaData<- VertexMetaData %>%
  left_join(., simulation_power, by = c("Name"= "Node")) %>%
  mutate(Generation = ifelse(is.na(Sim_power), Generation, Sim_power)) %>%
  select(-Sim_power)

Profile_graph <- g %>%
  as_data_frame(., what = "edges") %>%
  graph_from_data_frame(., directed = FALSE, vertices = Profile_VertexMetaData)

#Ensure there is powerflow
Profile_graph<- BalencedGenDem(Profile_graph, "Demand", "Generation")
SlackRef <- SlackRefFunc(Profile_graph) #find the most appropriate node to be the slack bus
Profile_graph <- PowerFlow(Profile_graph, SlackRef$name) #calculate power flow

return(Profile_graph)
  
}
```


##No Coal
```{r}
{
  #NO coal partial CCGT
  simulation_power <- Generator_details %>%
    mutate(Power_code = 
             case_when(
               Generator.Type=="Coal" ~ "2",
               Generator.Type=="CCGT" ~ "1",
               TRUE ~"0")) %>%
    arrange(Max_power) %>% #order from smallest to largest
    arrange(Power_code) %>%#then order by the power codes I just defined
    mutate(power_sum = cumsum(Max_power)/sum(trans1$Demand))
  
  critical_point <- simulation_power %>%
    pull(power_sum) %>% .[min(which(simulation_power$power_sum > 1))]
  
  simulation_power <- simulation_power %>%
    mutate(Active_gen = power_sum<= critical_point,
           Max_power = ifelse(Active_gen, Max_power, 0)) %>%
    group_by(Node) %>%
    summarise(Sim_power = sum(Max_power))
  }


No_Coal <- create_profile_g(simulation_power, VertexMetaData, g)

```


##No Renewables
```{r}
{
  #NO coal partial CCGT
  simulation_power <- Generator_details %>%
    mutate(Power_code = 
             case_when(
               Carbon_type=="Carbon" ~ "0",
               TRUE ~"1")) %>%
    arrange(Max_power) %>% #order from smallest to largest
    arrange(Power_code) %>%#then order by the power codes I just defined
    mutate(power_sum = cumsum(Max_power)/sum(trans1$Demand))
  
  critical_point <- simulation_power %>%
    pull(power_sum) %>% .[min(which(simulation_power$power_sum > 1))]
  
  simulation_power <- simulation_power %>%
    mutate(Active_gen = power_sum<= critical_point,
           Max_power = ifelse(Power_code==0, Max_power, 0)) %>%
    group_by(Node) %>%
    summarise(Sim_power = sum(Max_power))
}

No_Renewables <- create_profile_g(simulation_power, VertexMetaData, g)

```

##No Nuclear
```{r}
{
  #NO coal partial CCGT
  simulation_power <- Generator_details %>%
    mutate(Power_code = 
             case_when(
               Generator.Type=="Nuclear" ~ "0",
               TRUE ~"1")) %>%
    arrange(Max_power) %>% #order from smallest to largest
    arrange(Power_code) %>%#then order by the power codes I just defined
    mutate(power_sum = cumsum(Max_power)/sum(trans1$Demand))
  
  critical_point <- simulation_power %>%
    pull(power_sum) %>% .[min(which(simulation_power$power_sum > 1))]
  
  simulation_power <- simulation_power %>%
    mutate(Active_gen = power_sum<= critical_point,
           Max_power = ifelse(Power_code==0, Max_power, 0)) %>%
    group_by(Node) %>%
    summarise(Sim_power = sum(Max_power))
}

No_Nuclear <- create_profile_g(simulation_power, VertexMetaData, g)
```

##simulation strains
```{r}

sim_names <- c("No_Coal", "No_Renewables", "No_Nuclear")

sim_names %>%
  walk(~{
    
    strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    #only generate if file not there
    if(!file.exists(strain_file_path)){
      
      g2 <- get(.x)
      
      g2 <-set.edge.attribute(g2, "Imp", value = 1/get.edge.attribute(g, "Y"))
      g2 <-set.edge.attribute(g2, "distance", value = 1) %>%
        Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", minimum_value = 100, stretch_range = 1000) %>%
        set.edge.attribute(., "Area", value = 1)
      g2 <-Normalize_load(g2, EdgeName = Link, VertexName = name, Net_Generation = BalencedPower, capacity = Link.Limit,
                          Generation = Generation, Demand = Demand)
      
      List_of_BiConComps <- Create_balanced_blocks(g2, force = "BalencedPower")

      #use the largest block to set the simulation parameters k and m.
      #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
      OriginBlock <- Find_network_balance(List_of_BiConComps[[147]], tstep = 0.05, tol = 1e-10, distance = "distance", 
                                          maxIter = 10000, mass = 1)
      
      final_z <- Create_stabilised_blocks(g2, OriginBlock, 147, tstep = 0.01, tol = 1e-10, 
                                          distance = "distance", maxIter = 20000, mass = 1)
      
      write_rds(final_z, strain_file_path)
      
    }
    
  })


height_profile_type <- sim_names %>%
  map_df(~{
    
    strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    read_rds(strain_file_path) %>%
      mutate(sim = .x)
    
  })


height_profile_type %>%
  select(node, z, sim) %>%
  spread(key = sim, value = z) %>%
  select(-node) %>% cor


strain_profile_type <- sim_names %>%
  map_df(~{
    
      strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    read_rds(strain_file_path) %>%
      Calc_line_strain(set.edge.attribute(g, "distance", value = 1), ., distance) %>%
      mutate(sim = .x)
    
  })

strain_profile_type %>%
  group_by(sim) %>%
  summarise(mean = mean(strain),
            median = median(strain))


kriged_sim <- sim_names %>%
  map_df(~{
    
    strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    Out2 <- kriged_height_strain_data <- krige_height_strain_maps(g = set.edge.attribute(g, "distance", value = 1), 
                                                      height_df = read_rds(strain_file_path), 
                                                      coords = MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
                                                        filter(PositionType=="Geo Space"), distance,
                                                      spatial_df = spdf) %>%
      mutate(simulation = .x)

    
  })


kriged_height_strain_data <- krige_height_strain_maps(g = set.edge.attribute(g, "distance", value = 1), 
                                                      height_df = final_z, 
                                                      coords = MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
                                                        filter(PositionType=="Geo Space"), distance,
                                                      spatial_df = spdf)


kriged_sim %>%
  mutate(simulation = gsub("_", " ", simulation)) %>%
  ggplot(aes(x=Longitude, y=Latitude)) + 
  geom_tile(aes(fill=Height)) + coord_equal() +
  facet_grid(type~simulation) +
  scale_fill_viridis_c() +
scale_colour_viridis_c(option = "plasma") +
  labs(title = "Height and Strain of the UK high-voltage power grid 
       after converting to a system of springs", fill = "Percentile") +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "right") #the legend position may want changing back to the more convential side.

```


