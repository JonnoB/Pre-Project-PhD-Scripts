---
title: "Untitled"
author: "Jonathan Bourne"
date: "22 March 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

https://github.com/schochastics/graphlayouts

https://github.com/hackl/tikz-network


some IEEE datasets
https://icseg.iti.illinois.edu/power-cases/

annpotate points with rectangles
https://ggforce.data-imaginist.com/reference/geom_mark_rect.html

#Set up
```{r Setup}

packages <- c("tidyverse", "igraph","readr","readxl", "broom", "stringr", "xtable", "rlang", "animation", "caret", "sf", "rgdal", "sf", "gstat", "automap", "rayshader", "latex2exp", "yardstick", "minpack.lm", "gganimate", "tmaptools", "rgeos", "raster")

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

select <- dplyr::select
arrange <- dplyr::arrange
sapply(packages, library, character.only = TRUE)

library(PowerGridNetworking)

#Set up file system to read the correct folders this switches between aws and windows mode

basewd <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder"
datafile <- "/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ETYSAppendixB"
LatexFolder <- "/home/jonno/Dropbox/Apps/ShareLaTeX/Physics model for analysing flow graphs" 
FiguresFolder <- file.path(LatexFolder, "Figures")
TablesFolder <- file.path(LatexFolder, "Tables")
MatricesFolder <- file.path(LatexFolder, "Matrices")
Tariff <- file.path(basewd,"Tariff and Transport")
PLwd <- "/media/jonno/Seagate Expansion Drive/System_Dynamics"
Deletion_Order_Folder <-  file.path("/home/jonno/Dropbox/AWS_Simulation_Files") #Only one of the deletion order folders is needed. Either Nodes or Edges
IEEE_Project_folder <- "/media/jonno/Seagate Expansion Drive/IEEE_Networks"
base_attack_folder <-"/media/jonno/Seagate Expansion Drive/System_Dynamics/Profile_attacks"

#Load necessary datasets and great the base powergrid network
source(file.path("/home/jonno/ProportionalLoading", "CreateGBase.R"))

#Load some other useful functions
list.files("/home/jonno/Useful_PhD__R_Functions", pattern = ".R", full.names = T) %>%
  walk(~source(.x))

list.files("/home/jonno/Flow_Spring_System", pattern = ".R", full.names = T) %>%
  walk(~source(.x))

VertexMetaData2 <- VertexMetaData %>%
  mutate(NodeType = case_when(
    BalencedPower>0 ~"Generator",
    BalencedPower< 0~"Demand",
    TRUE ~ "Transfer"
  ),
  NodeType2 = case_when(
    Demand>0 & Generation>0 ~"Hybrid",
    TRUE ~ NodeType
  )) %>% select(Name, NodeType, NodeType2, BalencedPower)



```

#Toy examples
The values created by this chunk are used for the toys examples in the paper
```{r}
    
all_toys <- tibble(flow = c(10,10,10,10, 0.5, 1, 1,1, 0.5, 0.5), k = c(250,500, 100, 1100, 500,500, 100, 1100,100, 1100))
toy_res <- 1:nrow(all_toys) %>% 
  map_df(~{  
current_settings <- all_toys %>% slice(.x)

    solution_angle <- nlsLM(Force ~ ForceV_from_angle(target_angle, k = k, d = 1), 
                            start = c(target_angle = pi/4), 
                            data = list(Force = current_settings$flow, k = current_settings$k), 
                            upper = pi/2)
   
    Out <- current_settings %>%
      mutate( theta_rads = coef(solution_angle)[1],
              theta_degs = theta_rads*360/(2*pi),
              delta_z = tan(theta_rads),
              delta_h = sqrt(delta_z^2 + 1)-1,
              strain = signif(delta_h,3) # this is because the distance is 1 and strain = (H-d)/d and H = delta_h+d
      ) %>%
      select( theta_rads, theta_degs, delta_z, flow, k, delta_h, strain)
    
    return(Out)
  })       

rm(all_toys); rm(toy_res) #deleted so they don't clutter the work space. They are quick to calculate and are never used again
   
```



#Psychadelic beard/boat

This plots the strain values of a 4 node three edge graph with a constant EC and varying alpha. It shows that strain is more expressive than either alpha, ec or a combination of the two

The code giveing the animation that shows convergence has been lost. The animation is pretty helpful so it is a good idea to do it again.
```{r}

#The function that calculate the force from the angle
ForceV_from_angle <- function(target_angle, k, d){
  #allows us to tune an angle to get a specific force. alternatively we can tune k and d!
  tibble(H = sqrt(d^2 * (1 + tan(target_angle)^2)),
         ForceT = k*(H-d), 
         ForceV = ForceT*sin(target_angle)) %>%
    pull(ForceV)
  
}

#Get all the possible combinations of each edge excluding height data
fixed_mean_alpha  <- 20:80 %>%
  map_df(~{
     BranchEC <-100-.x -20
    
     tibble(A = .x,
           B =10 + BranchEC*(0:100)/100,
           C = 10 +  BranchEC*(100:0)/100,)
    
  } ) %>%
  mutate(groupID = 1:n()) %>%
  gather(key = edge, value = capacity, - groupID) %>%
  left_join(tibble(edge = c("A", "B", "C"), 
                   flow = c(20,10,10)), #edge flow is always postive! 
            by = "edge") %>%
  mutate(alpha = capacity/abs(flow)) %>%
  group_by(groupID) %>%
  mutate(mean_alpha = mean(alpha), 
         flow_fract = abs(flow)/sum(ifelse(flow>0,flow,0)),
         excess_cap = sum(alpha*flow_fract)/3) %>%
  group_by(mean_alpha) %>%
  mutate(counts = n(),
         k = 100*(10-1)*(1-1/alpha)+100,
         rank = rank(excess_cap, ties.method = "random")) %>% 
  ungroup 

#Minimise the data down to only the usefully distinct data
Edge_combos <- fixed_mean_alpha  %>%
  distinct(alpha, flow, .keep_all = TRUE) %>%
  mutate(groupID2 = 1:n())

#Calculate heights for each node pair combination
Edge_combos_delta_z <- Edge_combos$groupID2  %>% 
  map_df(~{  
    if((.x/100)%%1 == 0){ (print(.x))} #print every 100
    
    current_settings <- Edge_combos   %>%
      filter(groupID2 == .x)
    
    solution_angle <- nlsLM(Force ~ ForceV_from_angle(target_angle, k = k, d = 1), 
                            start = c(target_angle = pi/4), 
                            data = list(Force = current_settings$flow, k = current_settings$k), 
                            upper = pi/2)
    
    
    Out <- current_settings %>%
      mutate( theta_rads = coef(solution_angle)[1],
              theta_degs = theta_rads*360/(2*pi),
              delta_z = tan(theta_rads),
              delta_h = sqrt(delta_z^2 + 1)-1,
              strain = delta_h # this is because the distance is 1 and strain = (H-d)/d and H = delta_h+d
      ) %>%
      select(groupID, theta_rads, theta_degs, delta_z, flow, alpha, k, delta_h, strain)
  })  

#calculate the ratio of excess capacity split between B and C then join with the alpha value by group
#using capcity or 1/alpha gives the same value 
toy_theta_temp <-  fixed_mean_alpha %>%
  select(groupID, edge, alpha, counts) %>%
  spread(key = edge, value = alpha) %>%
  mutate(
   B= 1/B,
    C = 1/C,
    ratio = (B)/(C+B)) %>%
  left_join(fixed_mean_alpha %>%
  select(groupID, mean_alpha) %>%
    distinct) %>%
    select(-A, -B, -C)

#get combine the previous df's together to get the angle across the system for all combinations
toy_height_data <- fixed_mean_alpha %>%
select(groupID, edge, flow, alpha) %>%
  #add in the height data
  left_join(Edge_combos_delta_z %>% select(-groupID))  %>%
  select(groupID, edge, strain) %>%
  #Use spread to keep the delta values for each edge
  spread(key = edge, value = strain) %>%
  mutate(mean_strain = (A+B+C)/3) %>%
  left_join(toy_theta_temp, by = "groupID")


  toy_height_data %>%
    # some of the mean_alpha values are seperating on machine tolerance or something
        mutate(mean_alpha = signif(mean_alpha,5)) %>% 
    #filter(mean_alpha <=2.5) %>%
    ggplot(aes(x = ratio, y = mean_strain, colour = mean_alpha, group = mean_alpha)) + 
    geom_line(size = 1) +
    scale_colour_viridis_c() +
    labs(title ="Strain and System Tolerance in terms of capacity fraction in edge B", 
         y = "System Strain", 
         x= latex2exp::TeX("$\\frac{\\tau_{B}}{\\tau_{B}+\\tau_{C}}$"),
         colour = "System \ntolerance") #latex2exp::TeX(paste("system", "$\\alpha$"))
  ggsave(file.path(FiguresFolder, "Constant_excess_capacity.pdf"))

"Relationship between alpha, excess capacity and theta"

latex2exp::TeX(paste("The relationship between strain and ", 
                                     "$\\alpha \\,$", 
                                     " in terms of capacity fraction in edge B" ))

toy_height_data %>%
  filter((mean_strain == min(mean_strain)))

fixed_mean_alpha %>%
  filter(groupID==2879)

```

##Entropic degree
```{r}

entropy_data<- fixed_mean_alpha %>%
  group_by(groupID) %>%
  mutate(p_capacity = capacity/sum(capacity),
         p_alpha = alpha/sum(alpha),
         entrop_capacity = -p_capacity*log(p_capacity),
         entrop_alpha = -p_alpha*log(p_alpha)) %>%
  summarise(capacity = sum(entrop_capacity),
            alpha = sum(entrop_alpha)) %>%
  #normalise the entropy relative to the highest value
  mutate(capacity = capacity/max(capacity), 
         alpha = alpha/max(alpha))

toy_height_data %>%
  select(groupID, mean_strain, mean_alpha) %>%
  left_join(entropy_data) %>%
  gather(key = type, value = div, -mean_strain, - mean_alpha,-groupID ) %>%
    mutate(mean_alpha = signif(mean_alpha,5)) %>%  # some of the mean_alpha values are seperating on machine tolerance or something
  ggplot(aes(x = div, y = mean_strain, colour = mean_alpha, group = mean_alpha)) + 
  geom_line(size = 1) +
  scale_colour_viridis_c() +
  facet_grid(~type) +
  labs(title = "The relationship between strain, system tolerance and entropy", 
       x = "Normalised entropy", 
       y ="system strain", 
       colour =  "Sytem
       tolerance")
ggsave(file.path(FiguresFolder, "entropy_theta.pdf"))



rm(entropy_data)
```

##The square
```{r}

alpha_values <- c(1,Inf, 1.05, 1.1, 2, 5)

edge_alpha <- expand.grid(AB_alpha =alpha_values, AC_alpha =alpha_values, BD_alpha =alpha_values, CD_alpha =alpha_values) %>% 
  as_tibble  %>%
  mutate(ID = 1:nrow(.),
         alpha = (AB_alpha+AC_alpha+BD_alpha+CD_alpha)/4,
         capacity = (AB_alpha*15+AC_alpha*15+BD_alpha*5+CD_alpha*5) ) 
%>%
  filter(AB_alpha >=AC_alpha)

grid_search_alpha <- 1:nrow(edge_alpha) %>% map_df(~{
  #set up graph
square_g <- tibble(from = c("A", "A", "B", "C"), 
                   to = c("B","C", "D", "D"), 
                   Link = paste0(from, to),
                   flow = c(15,15,5,5),
                   alpha = edge_alpha[.x,1:4] %>% as.numeric(), #545 is a good choice of row for testing
                   capacity = flow*alpha) %>%
  graph_from_data_frame(directed = FALSE)

#addin missing attributes
 square_g2 <-set.vertex.attribute(square_g, "Generation", value = c(30,-10,-10,-10))%>%
   set.edge.attribute(., "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., Force = "flow", Capacity = "capacity", 400, 40) %>%
    set.edge.attribute(., "Area", value = 1)

  #this needs to be normalised

#find equilibrium
 ptm <- proc.time()
 Square_heights <- Find_network_balance(square_g2, force = "Generation",
                                        flow = "flow",
                                        capacity = "capacity",
                                        tstep = 0.001, tol = 1e-10, distance = "distance", 
                                        maxIter = 4000, mass = 1)

# Stop the clock
elapsed_time <-proc.time() - ptm
#add iteration number and return
 Out <- Square_heights$NodeList %>%
   mutate(ID = .x,
          elapsed_time = elapsed_time[3])
 
 return(Out)
 
 })
 
write_rds(grid_search_alpha,file.path(PLwd, "grid_search_alpha.rds"))

 Square_heights$results %>%
   ggplot(aes(x = t, y = z)) + geom_line()
   
 grid_search_alpha %>%
  ggplot(aes(x = z, colour = node)) + geom_density() +
   labs(title = "Density of node height for the square graph")
 
test <- grid_search_alpha %>% as_tibble %>%
  select(node, z, ID) %>%
  spread(key = node, value = z) %>%
   mutate(AB_strain = sqrt((A-B)^2+1)-1,
          AC_strain = sqrt((A-C)^2+1)-1,
          BD_strain = sqrt((B-D)^2+1)-1,
          CD_strain = sqrt((C-D)^2+1)-1,
          strain = (AB_strain+AC_strain+BD_strain+CD_strain)/4) %>%
   left_join(edge_alpha) %>%
  mutate(joint = paste(alpha, capacity))

test2 <- test %>%
  group_by(joint) %>%
  summarise(counts = n(),
            strain_max = max(strain),
            strain_min = min(strain)) %>%
  mutate(diff = strain_max-strain_min)

strain_sum = test %>%
  mutate(strain = round(strain, 5)) %>%
 # filter(strain ==0.01006)
  group_by(strain, joint) %>%
  summarise(counts = n())

test %>%
 # filter(alpha<1.2) %>%
  ggplot(aes(colour = strain, y = alpha, x = (capacity), group = alpha)) +geom_point() +
  scale_color_viridis_c()


test2<- test %>%
  filter(#capacity<50,
         alpha<1.2)

```


##Convergance visualisation
I am not sure if I really need to have this in the paper
```{r}

nodes_4_3 <- tibble(name = 1:4, Generation = c(20, 0,0,0), Demand = c(0,0,10,10), force = c(20, 0, -10, -10),
                    norm_force = c(1, 0, -0.5, -0.5))


g_4_3 <- matrix(c(0, 1, 0,0,
          1,0,1,1,
         0,1,0,0,
         0,1,0,0), nrow = 4) %>%
  graph_from_adjacency_matrix(., mode = "undirected") %>%
  as_data_frame() %>% as_tibble %>%
  mutate(Link = LETTERS[1:3],#c("M_1", "Z_2", "A_3"),#LETTERS[1:3], #this is to check edge ordering the alpha ordering is A, M,Z
         alpha = c(1,1,7),
         flow = c(20,10,10),
         norm_flow = c(1,0.5,0.5),
         capacity = alpha*flow,
         norm_capacity = norm_flow*alpha) %>%
  graph_from_data_frame(., directed = FALSE, vertices = nodes_4_3) %>% 
  set.edge.attribute(., "distance", value = 1) %>%
  Calc_Spring_Youngs_Modulus(., "flow", "capacity", minimum_value = 10, stretch_range = 100) %>%
  set.edge.attribute(., "Area", value = 1) %>%
  set.edge.attribute(., "Y", value = 1/c(1:3))%>%
  set.vertex.attribute(., "name", value = c("Generation", "Transfer", "Demand 1", "Demand 2")) 

  #use the largest block to set the simulation parameters k and m.
  #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
simple_converge <- Find_network_balance_expanded(g_4_3, 
                                                 force = "force", 
                                                 flow ="flow", 
                                                 #capacity = "capacity", 
                                                 tstep = 0.01,
                                                 distance = "distance", 
                                                 mass = 1, 
                                                 maxIter = 250,
                                                 frctmultiplier = 1)


simple_converge %>%
 # filter(t<400) %>%
  ggplot(aes(y = z, x = t, colour = node)) + geom_line()
 
```


#IEEE118

This section uses the IEEE_118 network to demonstrate that strain is a proxy for the robustness of the network under random attack.

##plot IEEE118

```{r}
IEEE_Project_folder <- "/media/jonno/Seagate Expansion Drive/IEEE_Networks"

IEEE_118 <- readRDS(file.path(IEEE_Project_folder,"IEEE_network_files", "IEEE_118_igraph.rds"))


#set node coordinates for IEEE118
set.seed(2664)
IEEE118_heights <- IEEE_118 %>%
    as_data_frame(.) %>%
    select(from, to, Link, PowerFlow) %>%
    gather(key = "type", value = "Node",-Link,-PowerFlow) %>%
  left_join(layout_with_fr(IEEE_118) %>% 
    as_tibble %>% 
    mutate(Node = names(V(IEEE_118)))) %>%
  left_join(as_data_frame(IEEE_118, what = "vertices") %>%
  rename(Node = name)) %>%
  mutate(type = case_when(
    Net_Generation>0~"Generator",
    Net_Generation<0~"Demand",
    TRUE~"Transfer"
  )
  ) %>%
  left_join(., list.files(file.path(IEEE_Project_folder, "Solved_height_networks"), full.names = TRUE)[16] %>%
  read_rds(), by = c("Node"="node")
  ) %>%
  mutate(height_perc = percent_rank(z))



#Plot IEEE118 with fruchtman reingold expansion 
IEEE118_heights %>%
  ggplot(aes(x = V1, y = V2, group = Link)) + 
  geom_line() + #aes(colour = abs(PowerFlow)) 
  geom_point(aes(colour = height_perc, shape = type ), size =3)+
  labs(title = "IEEE118 power flow and node type, using Fruchtman Reingold expansion",
       shape = "Node type",
       colour = "Height Percentile") +
  scale_colour_viridis_c() +
  theme(axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank())
  ggsave(file.path(FiguresFolder, "IEE118_map.pdf"))
  
#system strain is 
  
```

##Strain alpha relationship

```{r}
target_orders  <- readRDS(file.path(IEEE_Project_folder, "target_orders.rds"))

IEEE_118_dist <- IEEE_118 %>%
  set.edge.attribute(., "distance", value = 1)%>%
  set.edge.attribute(., "Link.Limit", value = Inf)

IEEE_theta_by_alpha <- list.files(file.path(IEEE_Project_folder, "Solved_height_networks"), full.names = TRUE) %>%
  map_df(~{
    read_rds(.x) %>%
    Calc_line_strain(IEEE_118_dist , ., distance = distance) %>%
      summarise(theta_degs = mean(strain)) %>%
    #angle_from_solved_heights(.) %>%
    mutate(alpha = basename(.x),
           )  
  }) %>%
  mutate(alpha = gsub("IEEE_118_alpha_", "", alpha) %>%
           gsub(".rds", "",.) %>% as.numeric())

IEEE_theta_by_alpha_ec <- list.dirs(file.path(IEEE_Project_folder,"constant_ec_from_alpha"), recursive = FALSE) %>%
  map_df(~{
    Out <- list.files(.x, full.names = TRUE) %>%
      map_df(~{
        read_rds(.x) %>%
    Calc_line_strain(IEEE_118_dist , ., distance = distance) %>%
      summarise(theta_degs = mean(strain)) %>%
    #angle_from_solved_heights(.) %>%
          mutate(alpha = basename(.x))  
      }) %>%
      rename(v = alpha) %>%
      mutate( ec = basename(.x) %>% gsub("Solved_height_networks_alpha_", "", .),
              v = gsub("IEEE_118_v_", "", v) %>%
                gsub(".rds", "",.) %>% as.numeric )%>% 
      arrange(v) #%>% 
     bind_cols(target_orders) #This is the target orders from the IEEE script
    
    return(Out)
    
  })
```


##load all sims and find critical threshold

Data loaded from Create_IEEE_networks.Rmd

##Extract Nodes version
```{r}

critical_threshold <- function(g){
  #finds the critical threshold according to the molly reed criterion
  node_degree <-degree(g)
  k2_over_k <- mean(node_degree^2)/mean(node_degree)
  
  Out <- 1- 1/(k2_over_k-1)
  
  return(Out)
}


critical_threshold2 <- function(g){
  #finds the critical threshold according to the molly reed criterion
  node_degree <-degree(g)

    Out <- (mean(node_degree^2) - 2*mean(node_degree))>0

  return(Out)
}


#perc of nodes that need to be removed to lose giant component
critical_threshold(IEEE_118)

#remaining nodes
IEEE_118_critical <- round(118- critical_threshold(IEEE_118)*118, 0)

#Proportional loading
ExtractAttackStats(file.path(IEEE_Project_folder, "IEEE118"), 
                   file.path(IEEE_Project_folder, "SummaryData"),
                   Generation = "Net_Generation",
                   EdgeName = "Link")



list.dirs(file.path(IEEE_Project_folder,"IEEE_permute_edge_ec"), recursive = F) %>%
  walk(~{
    
    #scrambled edges alpha 2
    ExtractAttackStats(.x, 
                       file.path(IEEE_Project_folder, "SummaryData_ec_alpha_2", basename(.x)),
                       Generation = "Net_Generation",
                       EdgeName = "Link")
    
  })

#scrambled edges alpha 2
ExtractAttackStats(file.path(IEEE_Project_folder, "IEEE1118_const_ec"), 
                   file.path(IEEE_Project_folder, "SummaryData_ec_alpha_2"),
                   Generation = "Net_Generation",
                   EdgeName = "Link")



AttackRoundData <- list.files(path = file.path(IEEE_Project_folder,"SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x))   %>%
  arrange(-TotalNodes) %>%
  filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
  mutate(alpha = gsub("alpha_value_", "", alpha) %>% 
           as.numeric()/100)



AttackRoundData_ec_alpha_ec <- list.dirs(file.path(IEEE_Project_folder,"SummaryData_ec_alpha_2"), recursive = F) %>%
  map_df(~{
    
    list.files(.x, full.names = TRUE) %>%
      map_df(~read_rds(.x))     %>%
  arrange(-TotalNodes) %>%
  filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
      mutate(alpha_class = basename(.x))
    
  }) %>%
  group_by(alpha, alpha_class) %>%
  summarise(NodesAttacked = mean(NodesAttacked)) %>%
  ungroup %>%
  mutate(v = alpha %>% gsub("constant_ec_v", "", .) %>%
           as.numeric(.),
         ec = alpha_class %>% gsub("alpha_value_", "", .) %>%
           as.numeric(.)/100) %>%
  select(-alpha) %>%
  left_join(target_orders, by = c("ec", "v"))





```

##Extract Edges version
```{r}

#Proportional loading
ExtractAttackStats(file.path(IEEE_Project_folder, "IEEE118_edges"), 
                   file.path(IEEE_Project_folder, "SummaryData_edges_attack"),
                   Generation = "Net_Generation",
                   EdgeName = "Link")



list.dirs(file.path(IEEE_Project_folder,"IEEE_permute_edge_ec_Edge"), recursive = F) %>%
  walk(~{
    
    #scrambled edges alpha 2
    ExtractAttackStats(.x, 
                       file.path(IEEE_Project_folder, "SummaryData_ec_alpha_2_Edge", basename(.x)),
                       Generation = "Net_Generation",
                       EdgeName = "Link")
    
  })


AttackRoundData <- list.files(path = file.path(IEEE_Project_folder,"SummaryData_edges_attack"), 
                              pattern = ".rds", 
                              full.names = TRUE) %>%
   map_df(~read_rds(.x))   %>%
  arrange(-TotalNodes) %>%
  mutate(has_gc = mean_degree_sqrd > 2*mean_degree) %>%
  filter(!has_gc) %>%
  #filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
  mutate(alpha = gsub("alpha_value_", "", alpha) %>% 
           as.numeric()/100)


AttackRoundData_ec_alpha_ec <- list.dirs(file.path(IEEE_Project_folder,"SummaryData_ec_alpha_2_Edge"), recursive = F) %>%
  map_df(~{
    
    list.files(.x, full.names = TRUE) %>%
      map_df(~read_rds(.x))     %>%
  arrange(-TotalNodes) %>%
  mutate(has_gc = mean_degree_sqrd > 2*mean_degree) %>%
  filter(!has_gc) %>%
  #filter(TotalNodes<= IEEE_118_critical) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
      mutate(alpha_class = basename(.x))
    
  }) %>%
  group_by(alpha, alpha_class) %>%
  summarise(NodesAttacked = mean(NodesAttacked)) %>%
  ungroup %>%
  mutate(v = alpha %>% gsub("constant_ec_v", "", .) %>%
           as.numeric(.),
         ec = alpha_class %>% gsub("alpha_value_", "", .) %>%
           as.numeric(.)/100) %>%
  select(-alpha) %>%
  left_join(target_orders, by = c("ec", "v"))

```


##plot scramble results
```{r}
relative_position <- function(strain_vect, ref_strain_vect){
  #this function finds the relative fraction of strain compared to the absolute max and min values of that parameter
  #strain_vect a numeric value of the mean strain of a network
  #ref_strain_vect a vector of values of at least two inclduing the strain in the network when k = c and k = RC
  (strain_vect-min(ref_strain_vect))/(max(ref_strain_vect)-min(ref_strain_vect))
  
}

#get the mean number of edges attacked per line loading alpha
theta_crit_thresh <- AttackRoundData %>%
  group_by(alpha) %>%
  summarise_all(mean) %>%
  left_join(IEEE_theta_by_alpha) %>%
  mutate(alpha = 1/alpha,
         orig_strain = theta_degs,
     theta_degs =   relative_position(theta_degs, IEEE_theta_by_alpha$theta_degs) 
     ) %>%
  mutate(true_alpha = 1/alpha)

#get the mean number of elements attacked for each of the hundred random attacks per scramble
theta_crit_thresh_ec_2 <- AttackRoundData_ec_alpha_ec  %>%
  left_join(IEEE_theta_by_alpha_ec %>% 
              mutate(ec = ec %>% as.numeric(.)/100)) %>%
  mutate(alpha = 1/alpha,
                  orig_strain = theta_degs,
         theta_degs =  relative_position(theta_degs, IEEE_theta_by_alpha$theta_degs)
         )

#reshape so that the alpha and strain values can be plotted
{
PropLoad_line <- theta_crit_thresh %>%
  select(alpha, NodesAttacked, theta_degs) %>%
  gather(key = type, value = value, -NodesAttacked) 
  
 PropLoad_line <-  bind_rows(PropLoad_line %>%
  mutate(type = ifelse(type=="alpha" , "alpha[sys]", "1/kappa~strain"), 
         bounded = FALSE),
  PropLoad_line %>% 
  mutate( type = ifelse(type=="alpha" , "1/alpha[sys]", "kappa~strain"), 
          value = 1/value,
          bounded = TRUE)) %>%
   mutate(type = factor(type, levels = c("1/alpha[sys]", "kappa~strain", "alpha[sys]", "1/kappa~strain")),
          Edge_perc = NodesAttacked/ecount(IEEE_118))

#reshape so that the alpha and strain values can be plotted

 scrambled_ec_points <- theta_crit_thresh_ec_2 %>%
               select(alpha, NodesAttacked, theta_degs, ec, v) %>%
               gather(key = type, value = value, -NodesAttacked, -ec, -v) %>%
  mutate(ec = factor(ec)#,
         #type = type %>%factor(., labels = c("1/alpha[sys]", "kappa~strain"))
         ) %>%
  mutate(alpha_limit = case_when(
    v == 1~ "min",
    v == 10~"max",
    TRUE ~"0ther"
  ))

  scrambled_ec_points <-  bind_rows(scrambled_ec_points %>%
  mutate(type = ifelse(type=="alpha" , "alpha[sys]", "1/kappa~strain"),
          bounded = FALSE),
  scrambled_ec_points %>% 
  mutate( type = ifelse(type=="alpha" , "1/alpha[sys]", "kappa~strain"), 
          value = 1/value,
          bounded = TRUE)) %>%
   mutate(type = factor(type, levels = c("1/alpha[sys]", "kappa~strain", "alpha[sys]", "1/kappa~strain")),
          Edge_perc = NodesAttacked/ecount(IEEE_118))

 
}

#plot the data to show that the strain value has a closer relationship to the proportional load than the alpha value does for both high and low values of strain.
PropLoad_line  %>%
  filter(bounded) %>%
  ggplot(aes(y = 1/value, x = Edge_perc)) + 
  geom_path() +
 # geom_line(data = scrambled_ec_points, aes(group = factor(v), colour = ec)) +
  geom_point(data = scrambled_ec_points  %>%
  filter(as.character(ec)%>% as.numeric()<30) %>% filter(bounded),# %>%  filter(ec !=100),
             aes(colour = ec)) +
  facet_wrap(~type, labeller = label_parsed) + #parsing shows the plotmath
  labs(title = "Analysing the spread of outcomes for mean loading and relative strain", 
       x = "Fraction of Edges Attacked", y = "metric value",
       colour = "Original\nsystem\ntolerance")  
#scale_colour_viridis_c()+
ggsave(file.path(FiguresFolder, "NodesAttacked_Strain_alpha_small_ec_118.pdf"))

PropLoad_line %>%
  filter(!bounded) %>%
  ggplot(aes(y = 1/value, x = NodesAttacked)) + 
  geom_path() +
 # geom_line(data = scrambled_ec_points, aes(group = factor(v), colour = ec)) +
  geom_point(data = scrambled_ec_points  %>%
  filter(as.character(ec)%>% as.numeric()<30) %>% filter(!bounded),# %>%  filter(ec !=100),
             aes(colour = ec)) +
  facet_wrap(~type, labeller = label_parsed) + #parsing shows the plotmath
  labs(title = "Analysing the spread of outcomes for alpha and one over relative strain", 
       x = "Edges Attacked", y = "metric value") +
  coord_cartesian(ylim = c(0,200))
ggsave(file.path(FiguresFolder, "NodesAttacked_Strain_alpha_large_ec_118.pdf"))

#This shows that the extrema from each group act as a boundary to the scrambled loads
PropLoad_line %>%
  filter(bounded) %>%
  ggplot(aes(y = 1/value, x = NodesAttacked)) + 
  geom_path() +
 # geom_line(data = scrambled_ec_points, aes(group = factor(v), colour = ec)) +
  geom_point(data = scrambled_ec_points %>%  filter(bounded),
             aes(colour = alpha_limit)) +
  facet_wrap(~type, scales = "free", labeller = label_parsed) + #parsing shows the plotmath
  labs(title = "Comparing strain for different alpha and excess capacity levels", 
       y = "Edges Attacked") 

```


#UK map 

##Set up UK Graph
```{r}

g <- RemoveDeadEnds(gbase) #remove non-valid ends from the graph
#Ensure there is powerflow
SlackRef <- SlackRefFunc(g) #find the most appropriate node to be the slack bus
g <- PowerFlow(g, SlackRef$name) #calculate power flow

test <- as_data_frame(g, what = "vertices")

#useful at various stages
energy_types <- c("Coal", "Gas", "Renewable", "Nuclear")
sim_names <- paste0("No_", energy_types)
```

##UK strain

###PL
```{r}

mean_alpha <- as_data_frame(g) %>%
  mutate(alpha = abs(PowerFlow/Link.Limit) ) %>%
  pull(alpha) %>% mean(.) %>%
  {1/.} %>% signif(.,3)

c(1, Inf, mean_alpha) %>% walk(~{
  
  alpha <- .x
  
  filename <- file.path(PLwd, "UK_strains", paste0("base_load_", alpha, ".rds"))
  
  print(paste("alpha value", alpha))
  if(!file.exists(filename)){
    
  current_graph  <- g %>%
    set.edge.attribute(. , "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", minimum_value = 100, stretch_range = 1000) %>%
    set.edge.attribute(., "Area", value = 1) %>%
  Normalize_load(., EdgeName = Link, VertexName = name, Net_Generation = BalencedPower, capacity = Link.Limit,
                         Generation = Generation, Demand = Demand)#%>%
#set.edge.attribute(., "flow", value = get.edge.attribute(., "PowerFlow"))
  
  List_of_BiConComps <- Create_balanced_blocks(current_graph, force = "BalencedPower")

  #Finds which of the components is the giant component so it can be used as the baseline
      giant_componant <-List_of_BiConComps %>% map_dbl(~vcount(.x)) %>% which.max()
      
      #use the largest block to set the simulation parameters k and m.
      #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
      OriginBlock_complete <- Find_network_balance(g = List_of_BiConComps[[giant_componant]], 
                                                   force ="BalencedPower",
                                                   flow = "PowerFlow",
                                                   distance = "distance",
                                                   capacity = "Link.Limit",
                                                   tstep = 0.05, 
                                                   tol = 1e-10, 
                                                   maxIter = 20000, 
                                                   mass = 1)
      
      final_z <- Create_stabilised_blocks(g = current_graph, 
                                          OriginBlock = OriginBlock_complete,
                                          OriginBlock_number = giant_componant, 
                                          force ="BalencedPower",
                                          flow = "PowerFlow",
                                          distance = "distance",
                                          capacity = "Link.Limit",
                                          tstep = 0.01, 
                                          tol = 1e-10, 
                                          maxIter = 20000, 
                                          mass = 1)
  
  write_rds(final_z, filename)
  
  }#end if statement
  
})

```


Shoe that there is low corellation betweeen line strain and alpha
###Base Load
```{r}

#create a sub graph that includes all the bicomponent of a node except the one that includes the active bi-comp

filename <- file.path(PLwd, "UK_strains", "UK_power_grid_base.rds")

if(file.exists(filename)){
  final_z <- read_rds(filename)
} else{
  
 current_graph  <- g %>%
    set.edge.attribute(. , "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", minimum_value = 100, stretch_range = 1000) %>%
    set.edge.attribute(., "Area", value = 1) %>%
  Normalize_load(., EdgeName = Link, VertexName = name, Net_Generation = BalencedPower, capacity = Link.Limit,
                         Generation = Generation, Demand = Demand)#%>%
#set.edge.attribute(., "flow", value = get.edge.attribute(., "PowerFlow"))
  
  List_of_BiConComps <- Create_balanced_blocks(current_graph, force = "BalencedPower")

  #Finds which of the components is the giant component so it can be used as the baseline
      giant_componant <-List_of_BiConComps %>% map_dbl(~vcount(.x)) %>% which.max()
      
      #use the largest block to set the simulation parameters k and m.
      #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
      OriginBlock_complete <- Find_network_balance(g = List_of_BiConComps[[giant_componant]], 
                                                   force ="BalencedPower",
                                                   flow = "PowerFlow",
                                                   distance = "distance",
                                                   capacity = "Link.Limit",
                                                   tstep = 0.05, 
                                                   tol = 1e-10, 
                                                   maxIter = 20000, 
                                                   mass = 1)
      
      final_z <- Create_stabilised_blocks(g = current_graph, 
                                          OriginBlock = OriginBlock_complete,
                                          OriginBlock_number = giant_componant, 
                                          force ="BalencedPower",
                                          flow = "PowerFlow",
                                          distance = "distance",
                                          capacity = "Link.Limit",
                                          tstep = 0.01, 
                                          tol = 1e-10, 
                                          maxIter = 20000, 
                                          mass = 1)
  
  write_rds(final_z, filename)
  
}




```

##Fiddle with strain
```{r}

#Is the strain power law distributed?
line_strain <-set.edge.attribute(g, "distance", value = 1) %>%
  Calc_line_strain(., final_z, distance= "distance", "Link.Limit", flow = "PowerFlow")


mean(line_strain$strain)

cor(line_strain$dz, line_strain$strain)
cor(line_strain$line_load, line_strain$strain)

z_network_map <-MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
  left_join(line_strain, by = c("Link"))%>%
   left_join(., final_z %>% select(node, z), by = c("Node"= "node")) 

z_network_map %>%
  #filter(!is.na(Perc)) %>%
    ggplot(aes(x = Longitude, y = Latitude)) + 
  geom_line(aes(group = Link, colour = percentile_strain), size = 0.8) + 
   facet_grid(~PositionType) + 
 # geom_point( aes(x = Latitude, y = Longitude, colour = percent_rank(z))) + 
  scale_color_viridis_c()+
  ggtitle("Strain map")


test <- node_height_edge_strain(set.edge.attribute(g, "distance", value = 1), 
                  final_z, 
                  MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
                    filter(PositionType=="Geo Space"), distance)

test2 <- test$edge_strain


node_z <-z_network_map %>% as_tibble %>%
  filter(PositionType=="Geo Space") %>%
  select(Node, Longitude, Latitude, z) %>%
  distinct(.keep_all = T) %>%
  left_join(Generator_details)

#only used for edge voronoi
# edge_z <-z_network_map %>% as_tibble %>%
#   filter(PositionType=="Geo Space") %>%
#   select(Longitude, Latitude, z, Link) %>%
#   group_by(Link) %>%
#   summarise_all(mean)

#Thifs is the strain of the network on each edge. It allows us to see the slope of the network
edge_strain <- z_network_map %>% as_tibble %>%
  filter(PositionType=="Geo Space") %>%
  select(Longitude, Latitude, z = strain, Link) %>%
  group_by(Link) %>%
  summarise_all(mean)

node_z2 <- node_z %>%
  left_join(VertexMetaData %>% rename(Node = Name)) %>%
  #all of this is to find the mid point
  arrange(Latitude) %>%
  mutate(lat_cumsum = cumsum(ifelse(BalencedPower>0, BalencedPower, 0)),
         lat_rev_cumsum = rev(lat_cumsum),
         lat_diff = lat_cumsum - lat_rev_cumsum,
         lat_abs_diff = abs(lat_diff)) %>%
    arrange(Longitude) %>%
  mutate(lon_cumsum = cumsum(ifelse(BalencedPower>0, BalencedPower, 0)),
         lon_rev_cumsum = rev(lon_cumsum),
         lon_diff = lon_cumsum - lon_rev_cumsum,
         lon_abs_diff = abs(lon_diff))  %>%
  arrange(Latitude) %>% 
  mutate(mass = 1) %>%
  mutate(mass_lat_cumsum = cumsum(mass),
         mass_lat_rev_cumsum = rev(mass_lat_cumsum),
         mass_lat_diff = mass_lat_cumsum - mass_lat_rev_cumsum,
         mass_lat_abs_diff = abs(mass_lat_diff)) %>%
    arrange(Longitude) %>%
  mutate(mass_lon_cumsum = cumsum(mass),
         mass_lon_rev_cumsum = rev(mass_lon_cumsum),
         mass_lon_diff = mass_lon_cumsum - mass_lon_rev_cumsum,
         mass_lon_abs_diff = abs(mass_lon_diff))
```


##UK network plot
```{r}
shapefile <- file.path("/home/jonno/Dropbox/Jonathan_Bourne_Phd_Folder/ShapeFiles UK",
                       "Countries_December_2017_Ultra_Generalised_Clipped_Boundaries_in_UK_WGS84.shp")

GB <- st_read(shapefile) %>%
  filter(ctry17cd !="N92000002") %>%
  st_union()

#plots the uk network with the midpoint
ggplot(GB) +
  geom_sf() +
 # scale_fill_viridis("Area") +
  ggtitle("Node locations in the UK") +
 # theme_bw() +
  geom_line(data = z_network_map %>%
              filter(PositionType=="Geo Space"),  aes(x = Longitude, y = Latitude, group = Link)) +
   geom_point(data =node_z, aes(x = Longitude, y = Latitude, colour = z), alpha  = 0.7) +
  coord_sf(ylim = c(50,58.9))+
  scale_color_viridis_c() +
  geom_point(data = node_z2 %>% filter(lat_abs_diff== min(lat_abs_diff)),
             aes(x = Longitude, y = Latitude), 
             colour = "red") +
    geom_point(data = node_z2 %>% filter(lon_abs_diff== min(lon_abs_diff), Generation>0),
             aes(x = Longitude, y = Latitude), 
             colour = "cyan") #+
#These bits aren't working I don't know why but it doesn't really matter either
 # geom_hline(aes(yintercept = node_z2 %>% filter(Node == "BLAC") %>% pull(Latitude)[1]), colour = "red") +
   # geom_hline(aes(yintercept = node_z2 %>% filter(Node == "MOFF") %>% pull(Latitude)), colour = "red")+
    #geom_vline(aes(xintercept = node_z2 %>% filter(Node == "CONQ") %>% pull(Longitude)), colour = "cyan") 

```


##Kriging
```{r}

spdf <- as(GB, "Spatial") %>% st_as_sf %>%
  st_crop(c(xmin = -7.5, ymin = 50, xmax = 2, ymax = 59)) %>%
  as_Spatial()

kriged_height_strain_data <- krige_height_strain_maps(g = set.edge.attribute(g, "distance", value = 1), 
                                                      height_df = final_z, 
                                                      coords = MakeMapDF(g, read_csv(file.path(basewd, "point.csv")))  %>%
                                                        filter(PositionType=="Geo Space"), 
                                                      distance = "distance", 
                                                      capacity = "Link.Limit",
                                                      flow = "PowerFlow",
                                                      spatial_df = spdf)

kriged_height_strain_data %>%
  mutate(type = fct_relevel(type, "Line Load", after = Inf)) %>%
  ggplot(aes(x=Longitude, y=Latitude)) + 
  geom_tile(aes(fill=value_perc)) + coord_equal() +
  facet_grid(~type) +
  scale_fill_viridis_c() +
scale_colour_viridis_c(option = "plasma") +
  labs(title = "Height and Strain of the UK high-voltage power grid under base load generation", 
       fill = "Percentile") +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "right") #the legend position may want changing back to the more convential side.
  ggsave(file.path(FiguresFolder, "BritainKrigedTopology.pdf"))


```

#Generating profiles

look at grid strain using different generating profiles.

the carbon intensity data comes from 
https://www.ipcc.ch/report/renewable-energy-sources-and-climate-change-mitigation/
```{r}

Generator_details <-GenerationData %>% 
  select(Node = Site, Station, Generator.Type, Max_power = "Max.Contracted.TEC.at.Peak..Transport.Model.TEC.",
         Base_power = "Generation.Base....Tariff.Model.TEC.",
         Carbon_type = "Carbon...Low.Carbon") %>%
  filter(!is.na(Node), Max_power>0)  %>% #get rid of nodes without generation
  mutate(G_type2 = case_when(
    Generator.Type %in% c("Biomass", "Hydro", "Pump Storage", "Tidal", "Wind Offshore", "Wind Onshore") ~"Renewable",
    Generator.Type %in% c("CCGT", "CHP", "OCGT") ~"Gas",
    TRUE~Generator.Type
  ),
  power_diff = Max_power-Base_power) 
  
test %>%
  group_by(Carbon_type) %>%
  summarise(Max_power = sum(Max_power),
            Base_power = sum(Base_power))

#uses 50th percentile data
Carbon_intensity <-tibble(Generator.Type = c("Biomass", "CCGT", "Coal", "CHP", "Hydro", "Interconnectors", "Nuclear", "OCGT", "Pump Storage", "Tidal", "Wind Offshore", "Wind Onshore"),
      Carbon_intensity = c(18, 496, 1001, 469, 4, 68, 16, 469, 4, 8, 12, 12),
       value_type = c("IPCC", "IPPC", "IPPC", "Gas IPPC", "IPPC", "electrictymap.org france average", "IPCC", "IPCC", "Hydro level as it uses spare capcity for max efficiency", "IPCC","IPCC", "IPCC"))

Generator_details %>%
  group_by(Generator.Type) %>%
  summarise(Max_power = sum(Max_power),
            Base_power = sum(Base_power),
            Carbon_type = first(Carbon_type)) %>%
  left_join(., Carbon_intensity) %>%
  arrange(Max_power)  %>%
  mutate(Per_tot = Max_power/sum(Max_power)*100,
          Per_Dem = Max_power/sum(trans1$Demand)*100,
         cum_sum = cumsum(Max_power))
  
```

##profile function
```{r}
create_profile_g <- function(simulation_power, VertexMetaData, g){
  
  Profile_VertexMetaData<- VertexMetaData %>%
  left_join(., simulation_power, by = c("Name"= "Node")) %>%
  mutate(Generation = ifelse(is.na(Sim_power), Generation, Sim_power)) %>%
  select(-Sim_power)

Profile_graph <- g %>%
  as_data_frame(., what = "edges") %>%
  graph_from_data_frame(., directed = FALSE, vertices = Profile_VertexMetaData)

#Ensure there is powerflow
Profile_graph<- BalencedGenDem(Profile_graph, "Demand", "Generation")
Profile_graph_list <- Cascade(list(Profile_graph)) #ensure grid is stable
Profile_graph <- Profile_graph_list[[length(Profile_graph_list)]] #take the final graph
Profile_graph <- RemoveDeadEnds(Profile_graph) #the removal of power stations can create dead zones in the network, these need to be remvoed
Profile_graph<- BalencedGenDem(Profile_graph, "Demand", "Generation")
SlackRef <- SlackRefFunc(Profile_graph) #find the most appropriate node to be the slack bus
Profile_graph <- PowerFlow(Profile_graph, SlackRef$name) #calculate power flow

return(Profile_graph)
  
}

```


##Create profile networks
```{r}
#there are many more renewable sources than any other, as they are so much smaller
table(Generator_details$G_type2)

energy_types <- c("Coal", "Gas", "Renewable", "Nuclear")
sim_names <- paste0("No_", energy_types)


#Max power is used as otherwise edges are lost on No_coal and No_Nuclear.
#No gas is causes overloads in both cases and there is a substantial power deficit
energy_types  %>%
  walk(~{
    print(.x)
    simulation_power <- Generator_details %>%
      mutate(
        Active_power = ifelse(G_type2== .x ,0, Max_power)) %>% #change specified type of power to 0 
      group_by(Node) %>%
      summarise(Sim_power = sum(Active_power))
    
    g2 <- create_profile_g(simulation_power, VertexMetaData, g)
    
    assign(x = paste0("No_",.x), value = g2 , envir = .GlobalEnv ) #assign to global environment with identifiable name
    
  })

sim_names %>%
  map_df(~{ 
    g <-get(.x)
    
    g_df <- g %>% as_data_frame() %>%
      mutate(alpha = Link.Limit/abs(PowerFlow),
             line_load = 1/alpha)
    
    tibble(
      type = .x,
      
      edges = ecount(g), 
           nodes = vcount(g),
           GW_Gen = get.vertex.attribute(g, "BalencedPower") %>% ifelse(.>0,.,0) %>%sum(.)/1000,
            GW_Dem = get.vertex.attribute(g, "Demand") %>% ifelse(.>0,.,0) %>%sum(.)/1000,
      line_load = mean(g_df$line_load))
    })

```

##simulation strains
```{r}

sim_names %>%
  walk(~{
    
    strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    #only generate if file not there
    if(!file.exists(strain_file_path)){
      
      g2 <- get(.x)
      
      current_graph  <- g2 %>%
        set.edge.attribute(. , "distance", value = 1) %>%
        Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", minimum_value = 100, stretch_range = 1000) %>%
        set.edge.attribute(., "Area", value = 1) %>%
        Normalize_load(., EdgeName = Link, VertexName = name, Net_Generation = BalencedPower, capacity = Link.Limit,
                       Generation = Generation, Demand = Demand)#%>%
      #set.edge.attribute(., "flow", value = get.edge.attribute(., "PowerFlow"))
      
      List_of_BiConComps <- Create_balanced_blocks(current_graph, force = "BalencedPower")
      
      #Finds which of the components is the giant component so it can be used as the baseline
      giant_componant <-List_of_BiConComps %>% map_dbl(~vcount(.x)) %>% which.max()
      
      #use the largest block to set the simulation parameters k and m.
      #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
      OriginBlock_complete <- Find_network_balance(g = List_of_BiConComps[[giant_componant]], 
                                                   force ="BalencedPower",
                                                   flow = "PowerFlow",
                                                   distance = "distance",
                                                   capacity = "Link.Limit",
                                                   tstep = 0.05, 
                                                   tol = 1e-10, 
                                                   maxIter = 20000, 
                                                   mass = 1)
      
      final_z <- Create_stabilised_blocks(g = current_graph, 
                                          OriginBlock = OriginBlock_complete,
                                          OriginBlock_number = giant_componant, 
                                          force ="BalencedPower",
                                          flow = "PowerFlow",
                                          distance = "distance",
                                          capacity = "Link.Limit",
                                          tstep = 0.01, 
                                          tol = 1e-10, 
                                          maxIter = 20000, 
                                          mass = 1)
      
      write_rds(final_z, strain_file_path)
      
    }
    
  })


height_profile_type <- sim_names %>%
  map_df(~{
    
    strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    read_rds(strain_file_path) %>%
      mutate(sim = .x)
    
  })


height_profile_type %>%
  select(node, z, sim) %>%
  spread(key = sim, value = z) %>%
  select(-node) %>% cor


strain_profile_type <- sim_names %>%
  map_df(~{
    print(.x)
      strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    read_rds(strain_file_path) %>%
      Calc_line_strain(set.edge.attribute(get(.x), "distance", value = 1), ., "distance", "Link.Limit") %>%
      mutate(sim = .x,
             edges = ecount(get(.x)))
    
  }) %>%
  bind_rows( final_z %>%
               Calc_line_strain(set.edge.attribute(g, "distance", value = 1), ., "distance", "Link.Limit") %>%
               mutate(sim = "base_load",
             edges = ecount(g)))

#mean and median strain
mean_strain <- strain_profile_type %>%
 # filter(sim != "No_Gas") %>%
  group_by(sim) %>%
  summarise(mean_strain = mean(strain, na.rm = T),
            median_strain = median(strain, na.rm = T),
            mean_LL = mean(line_load),
            median_LL = median(line_load),
         edges = first(edges)) %>%
  mutate(rank_strain = rank(mean_strain),
         rank_LL = rank(mean_LL))
print(mean_strain)


ggplot(strain_profile_type, aes( x = sim, y = (strain), colour = sim)) +
  geom_boxplot()


kriged_sim <- sim_names[-2] %>%
  map_df(~{
    print(.x)
    strain_file_path <- file.path(PLwd,"Generation_types" , paste0(.x,".rds"))
    
    Out2 <- kriged_height_strain_data <- krige_height_strain_maps(g = set.edge.attribute(get(.x), "distance", value = 1), 
                                                                  height_df = read_rds(strain_file_path), 
                                                                  coords = MakeMapDF(get(.x), 
                                                                                     read_csv(file.path(basewd, "point.csv")))  %>%
                                                                    filter(PositionType=="Geo Space"),
                                                                  distance = "distance",
                                                                  capacity = "Link.Limit",
                                                                  flow = "PowerFlow",
                                                                  spatial_df = spdf) %>%
      mutate(simulation = .x)

    
  })


kriged_sim %>%
  filter(simulation !="No_Gas") %>%
  mutate(type = fct_relevel(type, "Line Load", after = Inf)) %>%
  group_by(type) %>%
  mutate(simulation = gsub("_", " ", simulation),
         value_perc = percent_rank(value)) %>%
  ggplot(aes(x=Longitude, y=Latitude)) + 
  geom_tile(aes(fill=value_perc)) + coord_equal() +
  facet_grid(type~simulation) +
  scale_fill_viridis_c() +
  labs(title = "Height and Strain of the UK high-voltage power grid in three different simulations", fill = "Percentile") +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "right") #the legend position may want changing back to the more convential side.
  ggsave(file.path(FiguresFolder, "BritainKrigedTopology_simulations.pdf"))
```


#Attack profiles
```{r}

{
  AttackRounds <- 1000
set.seed(1589)
DeleteOrders <- MultiAttackOrder(g, Target = "Edges", Sims =  100)  }
```


##baseload
```{r}

folder <- file.path(base_attack_folder, "base_load")
 
 if(!file.exists(folder)){
    dir.create(folder)
  }
SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T, Target = "Edges")   

```



##Pl
```{r}

mean_alpha <- as_data_frame(g) %>%
  mutate(alpha = abs(PowerFlow/Link.Limit) ) %>%
  pull(alpha) %>% mean(.) %>%
  {1/.} %>% signif(.,3)

#The two PL models
c(1, mean_alpha) %>% walk(~{
  
  gProp <- Proportional_Load(g, alpha = .x)
  
  folder <-  file.path(base_attack_folder, paste0("alpha_value_",  .x*100))
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(gProp, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T, Target = "Edges")    
})

#Topological

  folder <-  file.path(base_attack_folder, "Topological")
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(g, DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = F, Target = "Edges")   

```


##generation type
Attack each generation profile until complete collapse, and summarise the data.
```{r}
setwd("/media/jonno/Seagate Expansion Drive/System_Dynamics/Profile_attacks") #clean this up

sim_names %>%
  walk(~{
    
folder <- .x

  if(!file.exists(folder)){
    dir.create(folder)
  }

SaveMultiAttacks(get(.x), DeleteOrders, folder, TotalAttackRounds = AttackRounds, CascadeMode = T, Target = "Edges")    
    
  })




####
#### Extract the attacks into Summary data
####
ExtractAttackStats(file.path(PLwd,"Profile_attacks"), file.path(PLwd, "SummaryData"))

#Load the saved files
AttackRoundData <- list.files(path = file.path(PLwd,"SummaryData"), 
                              pattern = ".rds", 
                              full.names = TRUE)  %>%
   map_df(~read_rds(.x))   %>%
  arrange(-TotalNodes) %>%
  mutate(has_gc = mean_degree_sqrd > 2*mean_degree) %>%
  filter(!has_gc) %>%
  group_by(simulationID, alpha) %>%
  summarise_all(first) %>%
  mutate(alpha = ifelse(alpha=="Real_Limits", "base_load", alpha))

AttackRoundData %>%
  group_by(alpha) %>%
  summarise_all(mean)

AttackRoundData %>%
  left_join(mean_strain, by = c("alpha"="sim")) %>% 
  mutate(perc_edges = NodesAttacked/edges) %>%
  ggplot(aes(x = alpha, y = perc_edges, fill = alpha)) + geom_boxplot()

AttackRoundData %>%
  rename(sim = alpha) %>%
  group_by(sim) %>%
  summarise(mean_edges = mean(NodesAttacked)) %>%
  left_join(mean_strain) %>% 
  mutate(perc_edges = mean_edges/edges) %>%
  filter(sim != "No_Gas") %>%
  filter(complete.cases(.)) %>%
  ggplot(aes(x = perc_edges, y = mean_strain, colour = sim)) + geom_point()


AttackRoundData %>%
  rename(sim = alpha) %>%
  group_by(sim) %>%
  summarise(mean_edges = mean(NodesAttacked)) %>%
  left_join(mean_strain) %>% 
  mutate(perc_edges = mean_edges/edges) %>%
  filter(sim != "No_Gas") %>%
  filter(complete.cases(.)) %>%
  mutate(sim = sim %>% gsub("_", " ", .) %>% gsub("(^|[[:space:]])([[:alpha:]])", "\\1\\U\\2", ., perl=TRUE)
) %>%
  select(`Generation profile` = sim, `Edge fraction attacked` = perc_edges, `Strain` = mean_strain) %>%
xtable(.,  
       caption = "Relationship between strain and number of edges attacked before giant component collapse on UK power-grid", 
       label = "tab:UK_power") %>%
   print(type = "latex", file = file.path(FiguresFolder, "UK_power_strain.txt"))

```


```{r}
node_z_Generator <-z_network_map %>% as_tibble %>%
  filter(PositionType=="Geo Space") %>%
  select(Node, Longitude, Latitude, z) %>%
  distinct(.keep_all = T) %>%
  left_join(Generator_details) %>%
  mutate(G_type2 = case_when(
    Generator.Type %in% c("Biomass", "Hydro", "Pump Storage", "Tidal", "Wind Offshore", "Wind Onshore") ~"Renewable",
    Generator.Type %in% c("CCGT", "CHP", "OCGT") ~"Gas",
    TRUE~Generator.Type
  ))

test <- node_z_Generator %>%
  filter(Latitude<52, Longitude>0, !is.na(Generator.Type))
  


ggplot(GB) +
  geom_sf() +
  ggtitle("Generator locations in the UK") +
  geom_line(data = z_network_map %>%
              filter(PositionType=="Geo Space"),  aes(x = Longitude, y = Latitude, group = Link)) +
   geom_point(data =node_z_Generator %>%
                filter(!is.na(Generator.Type)) %>%
                filter(Generator.Type=="Interconnectors"), aes(x = Longitude, y = Latitude, colour = G_type2), alpha  = 0.7)+
  coord_sf(ylim = c(50,58.9)) 

```

#Airline network

the database is from "Database Name: Air Carrier Statistics (Form 41 Traffic)- All Carriers" a T-100 form data
main website, under the traffic section
https://www.bts.dot.gov/topics/airlines-and-airports-0

accessed 23-08-19


Airport codes and coords from
https://datahub.io/core/airport-codes#r


I had jqr package installation problems. jqr is a package buried deep in the dependencies of the GIS packages. THe librarires necessary for it can be installed on ubuntu like this

```{r}

#This function removes small polygons. small islands often dot the landscape of a country making the shape files much larger than may typically be needed. This function removes those small islands leaving only the larger polygons and can potentially greatly reduce shape file size.
#The function was taken from  https://gis.stackexchange.com/questions/62292/how-to-speed-up-the-plotting-of-polygons-in-r
  getSmallPolys <- function(poly, minarea=0.01) {
  # Get the areas
  areas <- lapply(poly@polygons, 
                  function(x) sapply(x@Polygons, function(y) y@area))

  # Quick summary of the areas
  print(quantile(unlist(areas)))

  # Which are the big polygons?
  bigpolys <- lapply(areas, function(x) which(x > minarea))
  length(unlist(bigpolys))

  # Get only the big polygons and extract them
  for(i in 1:length(bigpolys)){
    if(length(bigpolys[[i]]) >= 1 && bigpolys[[i]] >= 1){
      poly@polygons[[i]]@Polygons <- poly@polygons[[i]]@Polygons[bigpolys[[i]]]
      poly@polygons[[i]]@plotOrder <- 1:length(poly@polygons[[i]]@Polygons)
    }
  }
  return(poly)
}
```



```{r}
library(tigris)

us_map_raw <- states(cb = TRUE, class = "sf")


test <- tibble(NAME =  us_map_raw %>%pull(NAME), STUSPS = us_map_raw %>% pull(STUSPS))

exclude <- c("AK","AS","MP","GU", "HI", "PR", "VI")

test <- us_map_raw %>%
  filter(!(STUSPS %in% exclude)) 

us_map <- test %>% st_union()

us_map

```


```{r}
us_airline_raw <- read_csv(file.path(PLwd, "US-AirlineData", "934510551_T_T100_SEGMENT_ALL_CARRIER.csv"))
airport_codes.raw <- read_csv(file.path(PLwd, "US-AirlineData", "airport-codes_csv.csv"))

#get us map and process to make a manageble size
if(file.exists(file.path( PLwd, "US-AirlineData", "us_map.rds"))){
  
  us_map <- readRDS( file.path( PLwd, "US-AirlineData", "us_map.rds"))
  
}else{
us_map_raw<- getData('GADM', country='USA', level=1)  #Get the County Shapefile for the US


  us_map <- subset(us_map2, !(NAME_1 %in% c("Alaska", "Hawaii"))) %>% #Keep only continental united states
    aggregate() %>% #dissolve internal borders
    #simplify borders
    gSimplify(., tol=0.01, topologyPreserve=TRUE)  %>% 
    #remove tiny islands
    getSmallPolys(.) 
  
saveRDS(us_map, file.path( PLwd, "US-AirlineData", "us_map.rds"))
rm(us_map_raw)
}

#helper graph
#the graph is used to remove all nodes that are not in the giant component. isolated sub component are not relevent to the overall analysis
pre_g <-us_airline_raw   %>%
  filter(SEATS>0, PASSENGERS>0, SEATS> PASSENGERS, #remove all lines with no passengers and the 1 line where there are more passengers than seats
         ) %>%
  select(ORIGIN, DEST, everything()) %>%
  graph_from_data_frame(., directed = FALSE)

#All nodes in component 1. This is the component with the vast majority of nodes. Only component 1 will be analysed
membership_df <- tibble(names = names(components(pre_g)$membership), membership= components(pre_g)$membership) %>%
  filter(membership==1)

us_airline_edge <- pre_g %>%
  as_data_frame() %>%
  group_by(from, to) %>%
  summarise(SEATS = sum(SEATS),
            PASSENGERS = sum(PASSENGERS)) %>%
  ungroup %>%
  arrange(SEATS) %>%
  mutate(alpha = SEATS/PASSENGERS,
         cumsum = cumsum(SEATS)/sum(SEATS),
         perc_count = (1:n())/n(),
         Link = paste(from, to, sep = "-")) %>% 
    filter(to != from,
           from %in% membership_df$names,
           to %in% membership_df$names,
           cumsum>0.05) #there are about 40 self loops these are also removed

#remove the helper data.
rm(pre_g); rm(membership_df)

us_airline_node <- us_airline_edge %>% 
  {bind_rows(select(., name = from, PASSENGERS), 
             select(., name = to, PASSENGERS))} %>%
  group_by(name) %>%
  summarise_all(sum) %>%
  mutate(passen_center = PASSENGERS - mean(PASSENGERS),
         Generation = ifelse(passen_center>0, passen_center, 0),
         Demand = ifelse(passen_center<0, passen_center, 0),
         #Normalising the load and gen. 
         norm_factor = sum(Generation), #
         Generation = Generation/norm_factor,
         Demand = Demand/norm_factor,
         passen_center  = Generation + Demand) 

mean(us_airline_node$PASSENGERS)

us_airline_g <- graph_from_data_frame(us_airline_edge %>%
                                        mutate(passen_norm = PASSENGERS/ us_airline_node$norm_factor[1],
                                               seats_norm = SEATS/us_airline_node$norm_factor[1]), directed = FALSE, 
                                      vertices = us_airline_node)


if(file.exists(file.path(PLwd, "US-AirlineData", "airline_final_z.rds"))){
airline_final_z <- readRDS(file.path(PLwd, "US-AirlineData", "airline_final_z.rds"))
}else{

#By making this code run as a block I ensure that the network is only a single component
{  
  current_graph  <- us_airline_g %>%
    set.edge.attribute(. , "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., "seats_norm", "passen_norm", minimum_value = 100, stretch_range = 1000) %>%
    set.edge.attribute(., "Area", value = 1) 

  comps_vect <- components(current_graph)$membership
  
  current_graph <- delete_vertices(current_graph, names(comps_vect)[comps_vect==2])
  }
  
    List_of_BiConComps <- Create_balanced_blocks(current_graph, force = "passen_center", flow = "passen_norm")

  #Finds which of the components is the giant component so it can be used as the baseline
      giant_componant <-List_of_BiConComps %>% map_dbl(~vcount(.x)) %>% which.max()
      
      #use the largest block to set the simulation parameters k and m.
      #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
      OriginBlock_complete <- Find_network_balance(g = List_of_BiConComps[[giant_componant]], 
                                                   force ="passen_center",
                                                   flow = "passen_norm",
                                                   distance = "distance",
                                                   capacity = "seats_norm",
                                                   tstep = 0.05, 
                                                   tol = 1e-10, 
                                                   maxIter = 20000, 
                                                   mass = 1)
      
      airline_final_z <- Create_stabilised_blocks(g = current_graph, 
                                          OriginBlock = OriginBlock_complete,
                                          OriginBlock_number = giant_componant, 
                                          force ="passen_center",
                                          flow = "passen_norm",
                                          distance = "distance",
                                          capacity = "seats_norm",
                                          tstep = 0.05, 
                                          tol = 1e-10, 
                                          maxIter = 20000, 
                                          mass = 1)
  
  write_rds(airline_final_z, file.path(PLwd, "US-AirlineData", "airline_final_z.rds"))
  
}

airline_strain  <-Calc_line_strain(current_graph, airline_final_z, "distance", "seats_norm", flow = "passen_norm")
  


      mean(airline_strain$strain)/mean(line_strain$strain)
    (1/(mean(1/airline_strain$alpha)))/(1/(mean(1/line_strain$alpha)))
      
      tibble(strain = c(mean(airline_strain$strain),mean(line_strain$strain)), 
             load = c(mean(1/airline_strain$alpha),mean(1/line_strain$alpha)),
             type = c("Airline", "power")) %>%
        ggplot(aes(y = strain, x = load, colour = type)) + geom_point()
        
      test2 %>%
    ggplot(aes(x = t, y = velocity)) + geom_line()
      
  
airport_codes <-  airport_codes.raw %>%
  filter(iata_code %in% unique(airline_final_z$node),
         type !="closed") %>%
   separate(coordinates, into = c("Longitude", "Latitude"), sep = ",", convert = TRUE) %>%
        rename(node = iata_code,
               airport_type = type) 
 
airport_codes %>%
   left_join(airline_final_z, .) %>%
   filter(iso_country %in% c("US", "AS"),
          iso_region != "US-AK",
          iso_region != "US-HI")  %>%
   ggplot(aes(x = Longitude, y = Latitude, colour = percent_rank(z))) + 
   geom_point() +
   scale_color_viridis_c()

 airline_coords <-  as_data_frame(us_airline_g) %>%
   select(Link, from, to) %>%
   gather(key = type, value = node, -Link) %>%
   left_join(., airport_codes) %>%
  select(Link, type, Node = node, Longitude, Latitude) %>%
   filter(Node !="PPG", Node != "FGI")


 airline_kriged_height_strain_data <- krige_height_strain_maps(g = set.edge.attribute(us_airline_g, "distance", value = 1), 
                                                      height_df = airline_final_z, 
                                                      coords = airline_coords, 
                                                      distance = "distance", 
                                                      capacity = "seats_norm",
                                                      flow = "passen_norm",
                                                      spatial_df =us_map)
 
 
 
 airline_kriged_height_strain_data  %>%
  mutate(type = fct_relevel(type, "Line Load", after = Inf)) %>%
  ggplot(aes(x=Longitude, y=Latitude)) + 
  geom_tile(aes(fill=value_perc)) + coord_equal() +
  facet_grid(type~.) +
  scale_fill_viridis_c() +
scale_colour_viridis_c(option = "plasma") +
  labs(title = "Height and Strain of the UK high-voltage power grid under base load generation", 
       fill = "Percentile") +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "right") #the legend position may want changing back to the more convential side.

```


```{r}

airport_route_aggregates <- airline_coords %>%
  left_join(airline_strain) %>%
  select(Node, alpha, strain) %>%
  group_by(Node) %>%
  summarise_all(list(~mean(.), ~max(.),~min(.), ~median(.)))

#convert the dataframe to an sf object
node_z_sf <- airline_coords %>% 
  select(-Link) %>% #remove the link as this is irrelevant for knowing the airport coords
  group_by(Node) %>% 
  summarise_all(first) %>% #take only the first coordinates as all the others are the same #I should prob have an eaiser veriosn of this
  select(-type) %>%
  left_join(select(airline_final_z, Node = node, z)) %>%
  left_join(airport_route_aggregates %>% select(Node, alpha = alpha_median, strain = strain_median)) %>%
  mutate(z = percent_rank(z),
         alpha = percent_rank(alpha),
         strain = percent_rank(strain)) %>% 
  gather(key = type, value = value, -Node,-Longitude, -Latitude ) %>%
  st_as_sf(., coords = c("Longitude", "Latitude")) 
#add in the correct projection data to align with the map
st_crs(node_z_sf) <- CRS("+proj=longlat +datum=WGS84")
node_z_sf <- st_transform(node_z_sf, st_crs(us_map))

#create the tessellation
v <- st_voronoi(st_combine(node_z_sf)) 

#clip the tesselation then convert back into an sf object to allow the simple features to be joined back in
#the key simple feature is of course z
clipped_tess_node <- st_intersection(st_cast(v), st_union(us_map)) %>% 
  st_sf(geom=.) %>%
  st_join(node_z_sf) %>%
  filter(!is.na(type))

#voronoi of the nodes is pretty good
clipped_tess_node %>%
ggplot() + geom_sf(aes(fill = value, colour = value)) +
   scale_fill_viridis_c()+
    scale_colour_viridis_c() +
  facet_grid(type~.)+
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())


test <- node_z_sf %>%
  left_join(airport_codes, by = c("Node" = "node")) %>%
  filter(iso_country =="US",
         !(iso_region %in% paste("US", exclude, sep = "-"))) 


tibble(Node = pull(node_z_sf, Node), type = pull(node_z_sf, type), value = pull(node_z_sf, value)) %>%
  spread(key = type, value = value) %>%
  select(-Node) %>%
  cor

#basically no corellation between alpha and strain
airline_strain %>%
  select(alpha, strain) %>%
  cor

```

