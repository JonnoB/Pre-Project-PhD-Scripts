---
title: "Untitled"
author: "Jonathan Bourne"
date: "29 April 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---






```{r}
IEEE_data_folder <- file.path(basewd, "IEEE power flow data")
Project_folder <- "/media/jonno/Seagate Expansion Drive/IEEE_Networks"
IEEE_networks <- file.path(Project_folder, "IEEE_network_files")

```


#Create the network
```{r}
test <- read_delim(file = file.path(IEEE_data_folder, "ieee118cdf.txt"),
                       delim = " ",
                       #skip = 2,
                       col_names = FALSE)

#each file is broken up into cards which represent different parts of the network
#The first two cards are nodes and edges respectively. At the end of each of the main cards the number -999 is shown.
#The final -999 is the end of the file followby by a single text line.

card_end <- read_delim(file = file.path(IEEE_data_folder, "ieee118cdf.txt"),
                       delim = " ",
                       col_names = FALSE) %>% 
  pull(1) %>% 
  {. =="-999"} %>% 
  which

skip <- 2
nodes <- read_delim(file = file.path(IEEE_data_folder, "ieee118cdf.txt"),
                       delim = " ",
                       skip = skip,
                       col_names = FALSE,
                                       trim_ws = TRUE,
                   n_max = card_end[1]-1-skip) %>%
  set_names(c("Bus_Number", "Name", "Area_Number", "drop", "Loss_zone", "Type" , "final_voltage_pu", "final_angle_degs", "Load_MW", "LOAD_MVAR", "Generation_MW", "Generation_MVAR", "Base_KV", "Desired_volts_pu", "Max_MVAR", "Min_MVAR", "Conductance", "Susceptance", "Remote_controlled_Bus_number" ))


#A couple of node names appear twice, so I use the Bus number as the official name of the node
#This causes issues to do with the edge name
test <- nodes %>%
  group_by(Bus_Number, Name) %>%
  summarise(counts = n()) %>%
  group_by(Name) %>%
  summarise(counts = n()) %>%
  filter(counts>1)

skip <- card_end[1]+1
edges <- read_delim(file = file.path(IEEE_data_folder, "ieee118cdf.txt"),
                   delim = " ",
                   skip = skip,
                   col_names = FALSE,
                   trim_ws = TRUE,
                   n_max = card_end[2]-1-skip) %>%
  set_names(c("Tap_bus_number", "Z_bus_number", "Load_flow_area", "Loss_zone", "Circuit", "Type", "Branch_resistance_R_pr_unit", "Branch_resistance_X_pr_unit", "Line_charging_B_pr_unit", "Line_MVA rating_No_1", "Line_MVA_rating_No_2", "Line_MVA_rating_No_3", "Control_bus_number", "Side", "Transformer_final_turns_ratio", "Transformer_final_angle", "Minimum_tap_phase_shift", "Maximum_tap_phase_shift", "Step_size", "Minimum_voltage", "Maximum_voltage"))


#The edges with near zero variance are unused anyway so I can drop them without issues
edges2 <- edges %>%
  mutate(Y = 1/Branch_resistance_X_pr_unit) %>%#We are using the DC assumuptions and the value of R is small compared to X thus we can say susceptance B = 1/X
  rename(from = Tap_bus_number, to = Z_bus_number) %>%
  select(-nearZeroVar(.),-Branch_resistance_R_pr_unit,-Branch_resistance_X_pr_unit) %>%
  left_join(select(nodes, from = Bus_Number, Name), by = "from")%>%
  left_join(select(nodes, to = Bus_Number, Name), by = "to") %>%
  mutate(Link = paste(Name.x, Name.y, sep = "-")) %>%
  select(-Name.x,-Name.y) %>%
  group_by(from, to) %>%
  #Remove parallel lines summing the susceptances
  summarise(Y = sum(Y),
            Link = first(Link)) 
  

  nodes2 <-nodes %>% select(-nearZeroVar(.)) %>%
    mutate(Net_Generation = Generation_MW - Load_MW)


IEEE_118 <- graph_from_data_frame(edges2, vertices = nodes2, directed = FALSE)

#The forces need balancing
IEEE_118 <-  BalencedGenDem(IEEE_118, 
                   Demand = "Load_MW",
                   Generation = "Generation_MW",
                   OutputVar = "Net_Generation")

SlackRef <- SlackRefFunc(IEEE_118, name = "name", Generation = "Generation_MW")

IEEE_118 <- PowerFlow(IEEE_118, SlackRef$name, EdgeName ="Link", VertexName = "name", Net_generation = "Net_Generation")

saveRDS(IEEE_118, file = file.path(IEEE_networks, "IEEE_118_igraph.rds"))
    
```


#Plot 118

```{r}
test2 <- as_data_frame(IEEE_118) %>%
  mutate(absPF = abs(PowerFlow),
         rank = rank(absPF))


NodePosition <- test2 %>%
  select(from, to, Link, PowerFlow) %>%
  gather(key = type, value = Node, -Link, -PowerFlow)

 set.seed(158)
  BaseCoords <- layout_with_fr(IEEE_118) %>% 
    as_tibble %>% 
    mutate(Node = names(V(IEEE_118))) %>%
    rename(Longitude = V1,
           Latitude = V2) %>%
    left_join(NodePosition, .) %>%
    left_join(nodes2 %>% 
                select(Node = Bus_Number, Name, Net_Generation) %>% 
                mutate(Node = as.character(Node),
                       Node_type = case_when(Net_Generation ==0 ~"Transmission",
                                        Net_Generation > 0 ~"Generation",
                                        TRUE ~"Demand")), .)

  BaseCoords %>%
  ggplot(aes(x = Longitude, y = Latitude, group = Link)) + geom_line() +  
    geom_point(aes(shape = Node_type, colour = Node_type))
  
    BaseCoords %>%
  ggplot(aes(x = Longitude, y = Latitude, group = Link, colour = abs(PowerFlow))) + geom_line() +  
    geom_point(aes(shape = Node_type), size = 2) +
    scale_color_viridis_c()

```


#IEEE 118 proportional attack


```{r}

IEEE_118 <- readRDS(file = file.path(IEEE_networks, "IEEE_118_igraph.rds"))
setwd(file.path(Project_folder, "IEEE118_edges"))

rep <-5
alpha_vector <- c(1, 1.02, 1.01, 1.005, 1.05, 1.1, 1.2, 1.5, 2, 3, 5, 7, 10, 15, 20, 50, 100, 200)[c(0,6,12)+rep]
alpha_vector
set.seed(21256)
DeleteOrders <- MultiAttackOrder(IEEE_118, Target ="Edges", Sims = 100, Name = "Link")  

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  gProp <- Proportional_Load(IEEE_118, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  SaveMultiAttacks(gProp, DeleteOrders, folder, 
                   TotalAttackRounds = 1000, 
                   CascadeMode = TRUE,
                   Demand = "Load_MW",
                   Generation = "Generation_MW",
                   EdgeName = "Link", 
                   VertexName = "name", 
                   Net_generation = "Net_Generation",
                   Target = "Edges")
  
}

)



```


```{r}
set.seed(21256)
DeleteOrders <- MultiAttackOrder(IEEE_118, Sims = 100)  


#The vector of alpha values to be tested
alpha_vector <- c(1, 1.05, 1.1, 1.2, 1.5, 2, 3, 5, 7, 10)
setwd(file.path(Project_folder, "IEEE118"))

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  gProp <- Proportional_Load(IEEE_118, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  SaveMultiAttacks(gProp, DeleteOrders, folder, 
                   TotalAttackRounds = 1000, 
                   CascadeMode = TRUE,
                   Demand = "Load_MW",
                   Generation = "Generation_MW",
                   EdgeName = "Link", 
                   VertexName = "name", 
                   Net_generation = "Net_Generation")
  
}

)






alpha_vector <- c(1.05, 1.1, 1.2, 1.5, 2, 3, 5, 7, 10)
setwd(file.path(Project_folder, "Max_vulnerability"))

#Create the simulations for each of the alpha avalues using 100 simulations for each
alpha_vector %>% walk(~{
  
  gProp <- Proportional_Load(IEEE_118, alpha = .x)
  
  folder <- paste0("alpha_value_",  .x*100)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
Total_Flow <- get.edge.attribute(gProp, "PowerFlow") %>% abs %>% sum

Total_Capacity <- Total_Flow*.x  

Excess_Capacity <- Total_Capacity - Total_Flow

temp <- as_data_frame(gProp) %>%
  mutate(Link.Limit = ifelse(abs(PowerFlow) == min(abs(PowerFlow)), abs(PowerFlow) + Excess_Capacity, abs(PowerFlow)),
         alpha = Link.Limit/abs(PowerFlow))

  SaveMultiAttacks(gProp, DeleteOrders, folder, 
                   TotalAttackRounds = 1000, 
                   CascadeMode = TRUE,
                   Demand = "Load_MW",
                   Generation = "Generation_MW",
                   EdgeName = "Link", 
                   VertexName = "name", 
                   Net_generation = "Net_Generation")
  
}

)



```

#Target orders


```{r}
Scramble_ec_values <- c(1.005, 1.05, 1.1, 1.2, 1.5, 2, 3, 5, 7, 10, 100) 
```


```{r}

if(!file.exists(file.path(Project_folder, "target_orders.rds"))){
  
  set.seed(123)
  random_seeds <- sample(1:100000, 10000)
  
  target_orders <- Scramble_ec_values %>% map_df(~{
    
    print(.x)
    #create network
    Scrambled_edge_cap <-  Proportional_Load(IEEE_118, alpha = .x)
    #permute edges
    print("creating the random permutations")
    seed_alpha <- Permute_excess_capacity(Scrambled_edge_cap, random_seeds)
    #take subselection
    target_orders <- sub_selection_of_seed_alpha(seed_alpha, total_samples = 10, seed = 123) %>%
      mutate(ec = .x,
             v = 1:n())
    
    return(target_orders)
    
  })
  
  saveRDS(target_orders, file.path(Project_folder, "target_orders.rds"))
  
} else {
  
  target_orders  <- readRDS(file.path(Project_folder, "target_orders.rds"))
  
}




```

#Do a multi-attack on each fixed ec

##Node attack
```{r}
Scramble_ec_values[c(1,11)] %>% walk(~{
  
  target_orders_x<- target_orders %>% 
    filter(ec == .x)
  
  folder <- paste0("alpha_value_",  .x*100) %>%
    file.path(Project_folder, "IEEE_permute_edge_ec_Node", .)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  #attack network using the deletion orders
  setwd(folder)
  #create network
  Scrambled_edge_cap <-  Proportional_Load(IEEE_118, alpha = .x)
  #attack!
  Scrambled_Edge_SaveMultiAttacks(target_orders_x, Scrambled_edge_cap, "constant_ec_v", DeleteOrders)
  
})
  
  seed_alpha %>%
  ggplot(aes(x = alpha)) + geom_density()
```

##Edge attack
```{r}
IEEE_118<- readRDS(file = file.path(IEEE_networks, "IEEE_118_igraph.rds"))
set.seed(21256)
DeleteOrders <- MultiAttackOrder(IEEE_118, Target ="Edges", Sims = 100, Name = "Link")  
Scramble_ec_values %>% walk(~{
  
  target_orders_x <- target_orders %>% 
    filter(ec == .x)
  
  folder <- paste0("alpha_value_",  .x*100) %>%
    file.path(Project_folder, "IEEE_permute_edge_ec_Edge", .)
  #create folder if it doesn't already exist
  if(!file.exists(folder)){
    dir.create(folder)
  }
  
  #attack network using the deletion orders
  setwd(folder)
  #create network
  Scrambled_edge_cap <-  Proportional_Load(IEEE_118, alpha = .x)
  #attack!
  Scrambled_Edge_SaveMultiAttacks(target_orders_x, Scrambled_edge_cap, "constant_ec_v", DeleteOrders, Target = "Edges")
  
})

```


#calculate the angle of the selected networks


The below chunk was put in due to simulations being run with different parameters resulting in out of synch heights. The common values will be used for both the proportionally loaded edges and the ec scrambled edges
```{r}
common_time <- 0.03
common_Iter <- 25000
common_tol <- 1e-10
common_mass <- 5000
```


##Propoortionally loaded angles

```{r}
IEEE_Project_folder <- "/media/jonno/Seagate Expansion Drive/IEEE_Networks"

IEEE_118 <- readRDS(file.path(IEEE_Project_folder,"IEEE_network_files", "IEEE_118_igraph.rds"))



#Network loadings to find the angles for
alpha_vector <- c(1, 1.02, 1.01, 1.005, 1.05, 1.1, 1.2, 1.5, 2, 2.5, 3, 5, 7, 10, 15, 20, 50, 100, 200, Inf)

#calculate theta for all values of alpha
alpha_vector %>% walk(~{
  
  alpha <- .x
  
  print(paste("alpha value", alpha))
  
  current_graph  <- IEEE_118 %>%
    Proportional_Load(., alpha = alpha) %>% 
    set.edge.attribute(. , "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", 100, 10) %>%
    set.edge.attribute(., "Area", value = 1)
  
  List_of_BiConComps <- Create_balanced_blocks(current_graph, force = "Net_Generation")
  
  #use the largest block to set the simulation parameters k and m.
  #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
  OriginBlock <- Find_network_balance(List_of_BiConComps[[11]], force = "Net_Generation", 
                                      tstep = common_time, tol = common_tol, distance = "distance", 
                                      maxIter = common_Iter, mass = common_mass)
  
  final_z <- Create_stabilised_blocks(current_graph, OriginBlock, 11, force = "Net_Generation", 
                                      tstep = common_time, tol = common_tol, distance = "distance", 
                                      maxIter = common_Iter, mass = common_mass)
  
  write_rds(final_z, file.path(IEEE_Project_folder, "Solved_height_networks", paste0("IEEE_118_alpha_", alpha, ".rds")))
})


test <-OriginBlock$results

test %>% ggplot(aes(x = t, y = z)) + geom_line()

```


##Scrambled edge angles

```{r}

for(n in Scramble_ec_values){
  print(n)
  target_orders2 <- target_orders %>% 
    filter(ec == n)
  
  alpha_folder <-  paste0("Solved_height_networks_alpha_", n*100) %>%
    file.path(Project_folder, "constant_ec_from_alpha", .)
  #create folder if it doesn't already exist
  if(!file.exists(alpha_folder)){
    dir.create(alpha_folder)
  }
  
 1:nrow(target_orders2) %>% walk(~{
    
    ID <- .x
    
    print(paste("alpha value", ID))
    #create network
    Scrambled_edge_cap <-  Proportional_Load(IEEE_118, alpha = n)
    
    set.seed(target_orders2$seed[.x])
    ec_order <- sample(1:ecount(Scrambled_edge_cap), ecount(Scrambled_edge_cap) )
    
    temp <- as_data_frame(Scrambled_edge_cap) %>%
      mutate(ec = Link.Limit-abs(PowerFlow), #get excess capacity
             ec2 = ec[ec_order], #change order of excess capacity
             alpha = (abs(PowerFlow)+ec2)/abs(PowerFlow), #calculate alpha
             Link.Limit = abs(PowerFlow)+ec2)#re-order link limit
    
    print(mean(temp$alpha))
    
    current_graph <- Scrambled_edge_cap %>%
      set.edge.attribute(., "Link.Limit", value = temp$Link.Limit) %>% 
      set.edge.attribute(. , "distance", value = 1) %>%
      Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", 100, 10) %>%
      set.edge.attribute(., "Area", value = 1)
    
    List_of_BiConComps <- Create_balanced_blocks(current_graph, force = "Net_Generation")
    
    #use the largest block to set the simulation parameters k and m.
    #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
    OriginBlock <- Find_network_balance(List_of_BiConComps[[11]], force = "Net_Generation",
                                      tstep = common_time, tol = common_tol, distance = "distance", 
                                      maxIter = common_Iter, mass = common_mass)
    
    final_z <- Create_stabilised_blocks(current_graph, OriginBlock, 11, force = "Net_Generation",
                                      tstep = common_time, tol = common_tol, distance = "distance", 
                                      maxIter = common_Iter, mass = common_mass)
    
    write_rds(final_z, file.path(alpha_folder, paste0("IEEE_118_v_", ID, ".rds")))
  })
  
}
```


#Strain
This looks at how strain functions as a robustness metric

```{r}

Calc_line_strain <- function(g, solved_height_df, distance){
  
  line_strain <-as_data_frame(g) %>% as_tibble %>%
  left_join(., solved_height_df %>% select(node, z), by = c("from"= "node")) %>%
  left_join(., solved_height_df %>% select(node, z), by = c("to"= "node")) %>%
  mutate(dz = abs(z.x-z.y),
         mean_z = (z.x+z.y)/2,
         H = sqrt(dz^2 +{{distance}}^2),
         strain = (H-{{distance}})/{{distance}},
         alpha = Link.Limit/abs(PowerFlow),
         line_load = abs(PowerFlow)/Link.Limit,
         percentile_strain = percent_rank(strain)) %>%
  select(Link, alpha, line_load, dz, H, strain, percentile_strain, mean_z, PowerFlow)
  
}


test <- list.files("/media/jonno/Seagate Expansion Drive/IEEE_Networks/Solved_height_networks", full.names = T) %>%
  map_df(~{
    
    alpha <- basename(.x) %>% gsub("IEEE_118_alpha_", "", .) %>% gsub(".rds", "", .) %>% as.numeric()

    IEEE_118_test<- Proportional_Load(IEEE_118, alpha = alpha) %>%
      set.edge.attribute(. , "distance", value = 1)
    
    read_rds(.x) %>%
      Calc_line_strain(IEEE_118_test , ., distance = distance)

    
  })




test %>%
  ggplot(aes(x = strain, colour = as.factor(alpha))) + geom_density()

test_strain <- test %>%
  mutate(alpha = round(alpha, 5)) %>%
  group_by(alpha) %>%
  summarise(mean = mean(strain),
            median = median(strain),
            weighted.mean = weighted.mean(strain, abs(PowerFlow)),
            counts = n())

test_strain %>%
  ggplot()

test_strain %>%
  gather(key = type, value = strain, -alpha, -counts) %>%
  ggplot(aes(x = 1/alpha, y = strain, colour = type )) + geom_point()

```


#explore convergence

It seems that the algorithm is not converging properly.
I am getting large difference between the infinite model and the a = 10 random ex model.
This below chunk tries to test if 16k and t = 0.3 is good enough, or just what is going on



```{r}

#calculate theta for all values of alpha
finnesse_prop <-c(1.1, 1.05) %>% map_df(~{
  
  alpha <- .x
  
  print(paste("alpha value", alpha))
  
  current_graph  <- IEEE_118 %>%
    Proportional_Load(., alpha = alpha) %>% 
    set.edge.attribute(. , "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", 100, 10) %>%
    set.edge.attribute(., "Area", value = 1)
  
  List_of_BiConComps <- Create_balanced_blocks(current_graph, force = "Net_Generation")
  
  #use the largest block to set the simulation parameters k and m.
  #k needs to be sufficiently stretch to allow enough topology variation. otherwise all that happens is a surface angled in the direct of net power flow. Which is interesting but not that interesting
  OriginBlock <- Find_network_balance(List_of_BiConComps[[11]], force = "Net_Generation", 
                                      tstep = 0.01, tol = common_tol, distance = "distance", 
                                      maxIter = 75000, mass = common_mass)
  
  final_z <- Create_stabilised_blocks(current_graph, OriginBlock, 11, force = "Net_Generation", 
                                      tstep = 0.01, tol = common_tol, distance = "distance", 
                                      maxIter = 75000, mass = common_mass) %>%
    mutate(ec = .x)
  
return(final_z)
})


test <-c(1.05, 1.1) %>% map_df(~{
  
test_g <- IEEE_118  %>%
    Proportional_Load(., alpha = .x) %>% 
    set.edge.attribute(. , "distance", value = 1) %>%
    Calc_Spring_Youngs_Modulus(., "PowerFlow", "Link.Limit", 100, 10)
  
  finnesse_prop %>%
    filter(ec == .x) %>%
  Calc_line_strain(test_g, ., distance) 
}) %>%
  mutate(alpha = round(alpha, 5)) %>%
  group_by(alpha) %>%
  summarise(strain = mean(strain))

test2 <- theta_crit_thresh %>%
  mutate(alpha = 1/alpha) %>%
  select(alpha,  NodesAttacked, theta_degs, orig_strain)

```
